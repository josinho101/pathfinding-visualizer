{"version":3,"sources":["enums/index.ts","components/grid/grid.tsx","appsettings.js","components/common/dropdown.tsx","helper/terrainhelper.ts","constants/index.ts","helper/utilityhelper.ts","helper/nodehelper.ts","components/stage/stagecontrols.tsx","components/grid/nodedescriptor.tsx","algorithms/terrain/randomterrain.ts","algorithms/terrain/recursivedivision.ts","algorithms/terrain/diagonallineterrain.ts","algorithms/terrain/terrainengine.ts","algorithms/pathfinding/dijkstra.ts","algorithms/pathfinding/pathfindingengine.ts","components/stage/stage.tsx","App.tsx","index.tsx"],"names":["NodeType","Algorithm","TerrainType","Grid","props","getColumn","node","identifier","row","column","id","key","draggable","isStart","isDestination","className","classNames","start","destination","brick","isBrick","onMouseEnter","onNodeMouseEnter","onDragStart","onNodeDragStart","onDragEnd","onNodeDropEnd","onDragOver","e","preventDefault","getRow","nodes","isPathFindingInProgress","onMouseDown","onGridContainerMouseDown","onMouseUp","onGridContainerMouseUp","rows","length","nodesArray","columns","push","rowId","jsxRow","generateGrid","settings","animationSpeed","min","max","default","Dropdown","classname","disabled","href","role","data-toggle","aria-haspopup","aria-expanded","selectedItem","options","filter","item","isSelected","value","getSelectedItemText","aria-labelledby","map","option","onClick","onOptionSelected","TerrainHelper","type","name","enums","None","RandomBricks","DiagonalLines","RecursiveDivision","getTerrainOption","selectedTerrain","none","getTerrainName","recursiveDivision","randomBricks","JTerrain","NodeClass","path","visited","UtilityHelper","Math","floor","random","Array","from","getRamdonNumber","sleep","milliseconds","Promise","resolve","setTimeout","NodeHelper","element","classList","contains","constants","grid","isNode","isStartNode","isDestinationNode","position","getNodePositionFromElemet","Start","Destination","nodeType","idParts","split","parseInt","document","getElementById","selectedAlgorithm","Dijkstra","getAlgorithmName","getAnimationSpeed","index","getDefaultNodePosition","createNode","defaultNodePosition","startRow","startColumn","destinationRow","destinationColumn","distance","Infinity","previousNode","undefined","isVisited","initNodes","numberOfRows","numberOfColumns","newRow","StageControls","speedRangeOptions","data-target","aria-controls","aria-label","onAlgorithmSelected","getAlgorithmOptions","onTerrainOptionSelected","onVisualizeClick","onResetStage","defaultValue","onChange","onSpeedChange","NodeDescriptor","getDescripor","text","cssClass","RandomTerrain","this","terrain","generateRandomArray","rowStart","rowEnd","colStart","colEnd","i","divide","col","forEach","DiagonalLineTerrain","TerrainEngine","terrainType","terrainGenerator","Error","getTerrain","mapTerrainToNodes","console","error","terrainRow","j","find","startNode","destinationNode","visitedNodes","unvisitedNodes","flatten2DNodeArray","sortNodeByDistance","adjacentNode","shift","updateDistanceOfUnvisitedNeighbors","nodesInShortestPath","currentNode","unshift","unvisitedNeighbours","getUnvisitedNeighbors","neighbor","neighbors","sort","a","b","PathFindingEngine","algorithm","pathFinder","animate","isStartOrDestination","nodeElement","getNodeFromDOM","remove","add","Stage","state","draggedNodeType","nodePositions","isPanStarted","setAnimationSpeed","event","target","weight","toggleBrick","setState","renderedOn","Date","now","onAlgorithmOptionSelected","resetStage","renderNodes","setTerrain","pathfindingEngine","getNodeType","getNodeClass","setAttribute","x","clientX","y","clientY","currentElement","elementFromPoint","newPosition","doRerenderNodes","React","Component","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6c38c0a1.chunk.js","sourcesContent":["/**\r\n * Enums for different nodes\r\n */\r\nexport enum NodeType {\r\n  None = 0,\r\n  Start = 1,\r\n  Destination = 2,\r\n  Path = 3,\r\n  UnVisited = 4,\r\n  Visited = 5,\r\n  Brick = 6,\r\n}\r\n\r\n/**\r\n * enum for path finding algorithms\r\n */\r\nexport enum Algorithm {\r\n  Dijkstra = 1,\r\n}\r\n\r\n/**\r\n * enum for different terrains\r\n */\r\nexport enum TerrainType {\r\n  None = 0,\r\n  RandomBricks = 1,\r\n  DiagonalLines = 2,\r\n  RecursiveDivision = 3,\r\n}\r\n","import React from \"react\";\r\nimport Node from \"./typings/node\";\r\nimport classNames from \"classnames\";\r\n\r\ninterface Props {\r\n  id: string;\r\n  nodes: Node[][];\r\n  isPathFindingInProgress: boolean;\r\n  onNodeDragStart: (e: React.DragEvent<HTMLDivElement>) => void;\r\n  onNodeDropEnd: (e: React.DragEvent<HTMLDivElement>) => void;\r\n  onNodeMouseEnter: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\r\n  onGridContainerMouseDown: (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => void;\r\n  onGridContainerMouseUp: (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => void;\r\n}\r\n\r\nconst Grid: React.FunctionComponent<Props> = (props) => {\r\n  const getColumn = (node: Node) => {\r\n    let identifier = `node-${node.row}-${node.column}`;\r\n    return (\r\n      <div\r\n        id={identifier}\r\n        key={identifier}\r\n        draggable={node.isStart || node.isDestination}\r\n        className={classNames(\r\n          \"node\",\r\n          { start: node.isStart },\r\n          { destination: node.isDestination },\r\n          { brick: node.isBrick }\r\n        )}\r\n        onMouseEnter={props.onNodeMouseEnter}\r\n        onDragStart={props.onNodeDragStart}\r\n        onDragEnd={props.onNodeDropEnd}\r\n        onDragOver={(e) => {\r\n          e.preventDefault();\r\n        }}\r\n      ></div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * return row of grid\r\n   */\r\n  const getRow = (id: string, nodes: JSX.Element[]) => {\r\n    return (\r\n      <div id={id} key={id} className=\"row\">\r\n        {[nodes]}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * generate grid\r\n   */\r\n  const generateGrid = (nodes: Node[][]) => {\r\n    let rows: JSX.Element[] = [];\r\n\r\n    for (let row = 0; row < nodes.length; row++) {\r\n      let nodesArray = nodes[row];\r\n      let columns: JSX.Element[] = [];\r\n\r\n      for (let column = 0; column < nodesArray.length; column++) {\r\n        columns.push(getColumn(nodesArray[column]));\r\n      }\r\n\r\n      let rowId = `row-${row}`;\r\n      let jsxRow = getRow(rowId, columns);\r\n\r\n      rows.push(jsxRow);\r\n    }\r\n\r\n    return rows;\r\n  };\r\n\r\n  return (\r\n    <div\r\n      id={props.id}\r\n      className={classNames(\"node-container\", {\r\n        \"block-mouse-events\": props.isPathFindingInProgress,\r\n      })}\r\n      onMouseDown={props.onGridContainerMouseDown}\r\n      onMouseUp={props.onGridContainerMouseUp}\r\n    >\r\n      {generateGrid(props.nodes)}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","let settings = {\r\n  animationSpeed: {\r\n    min: 1,\r\n    max: 10,\r\n    default: 5,\r\n  },\r\n};\r\n\r\nexport default settings;\r\n","import React from \"react\";\r\nimport classNames from \"classnames\";\r\nimport DropdownOption from \"./typings/dropdownoption\";\r\n\r\ninterface Props {\r\n  id: string;\r\n  disabled?: boolean;\r\n  options: DropdownOption[];\r\n  classname?: string;\r\n  onOptionSelected: (option: DropdownOption) => void;\r\n}\r\n\r\nconst Dropdown: React.FunctionComponent<Props> = (props) => {\r\n  // get selected item text\r\n  const getSelectedItemText = () => {\r\n    let selectedItem = props.options.filter((item) => item.isSelected);\r\n    if (selectedItem) {\r\n      return selectedItem[0].value;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * render all menu items\r\n   */\r\n  const renderMenuIems = () => {\r\n    return props.options.map((option: DropdownOption) => {\r\n      let id = `${props.id}-item-${option.id}`;\r\n      return (\r\n        <a\r\n          key={id}\r\n          id={id}\r\n          className=\"dropdown-item\"\r\n          href=\"#\"\r\n          onClick={() => {\r\n            props.onOptionSelected(option);\r\n          }}\r\n        >\r\n          {option.value}\r\n        </a>\r\n      );\r\n    });\r\n  };\r\n\r\n  return (\r\n    <li id={props.id} className=\"nav-item dropdown active\">\r\n      <a\r\n        className={classNames(\"nav-link dropdown-toggle\", props.classname, {\r\n          disabled: props.disabled,\r\n        })}\r\n        href=\"#\"\r\n        id=\"navbarDropdown\"\r\n        role=\"button\"\r\n        data-toggle=\"dropdown\"\r\n        aria-haspopup=\"true\"\r\n        aria-expanded=\"false\"\r\n      >\r\n        {getSelectedItemText()}\r\n      </a>\r\n      <div className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\r\n        {renderMenuIems()}\r\n      </div>\r\n    </li>\r\n  );\r\n};\r\n\r\nexport default Dropdown;\r\n","import * as enums from \"../enums\";\r\nimport DropdownOption from \"../components/common/typings/dropdownoption\";\r\nimport Node from \"../components/grid/typings/node\";\r\n\r\nclass TerrainHelper {\r\n  /**\r\n   * get terrain dropdown options\r\n   */\r\n  public static getTerrainOption = (selectedTerrain: enums.TerrainType) => {\r\n    let options: DropdownOption[] = [];\r\n\r\n    let none: DropdownOption = {\r\n      id: enums.TerrainType.None,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.None),\r\n      isSelected: false,\r\n    };\r\n\r\n    let recursiveDivision: DropdownOption = {\r\n      id: enums.TerrainType.RecursiveDivision,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.RecursiveDivision),\r\n      isSelected: false,\r\n    };\r\n\r\n    let randomBricks: DropdownOption = {\r\n      id: enums.TerrainType.RandomBricks,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.RandomBricks),\r\n      isSelected: false,\r\n    };\r\n\r\n    let JTerrain: DropdownOption = {\r\n      id: enums.TerrainType.DiagonalLines,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.DiagonalLines),\r\n      isSelected: false,\r\n    };\r\n\r\n    options.push(none);\r\n    options.push(recursiveDivision);\r\n    options.push(randomBricks);\r\n    options.push(JTerrain);\r\n\r\n    for (let option of options) {\r\n      option.isSelected = option.id === selectedTerrain;\r\n    }\r\n\r\n    return options;\r\n  };\r\n\r\n  /**\r\n   * get terrain name based on type\r\n   * @param type terrain type\r\n   */\r\n  public static getTerrainName(type: enums.TerrainType) {\r\n    let name = \"\";\r\n\r\n    switch (type) {\r\n      case enums.TerrainType.None:\r\n        name = \"Blank terrain\";\r\n        break;\r\n      case enums.TerrainType.RandomBricks:\r\n        name = \"Random bricks\";\r\n        break;\r\n      case enums.TerrainType.DiagonalLines:\r\n        name = \"Diagonal lines\";\r\n        break;\r\n      case enums.TerrainType.RecursiveDivision:\r\n        name = \"Recursive division\";\r\n        break;\r\n    }\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * set all nodes as non brick\r\n   * @param nodes nodes\r\n   */\r\n  public static removeAllBrickNode(nodes: Node[][]) {\r\n    for (const row of nodes) {\r\n      for (const column of row) {\r\n        column.isBrick = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default TerrainHelper;\r\n","let NodeClass = {\r\n  start: \"start\",\r\n  destination: \"destination\",\r\n  node: \"node\",\r\n  path: \"path\",\r\n  brick: \"brick\",\r\n  visited: \"visited\",\r\n};\r\n\r\nexport { NodeClass };\r\n","class UtilityHelper {\r\n  /**\r\n   * generate random numbers between min and max values\r\n   * @param min min value\r\n   * @param max max value\r\n   */\r\n  public static getRamdonNumber(min: number, max: number) {\r\n    return min + Math.floor(Math.random() * (max - min + 1));\r\n  }\r\n\r\n  /**\r\n   * sleep for the specified amount of time\r\n   */\r\n  public static sleep = (milliseconds: number) => {\r\n    return new Promise((resolve) => setTimeout(resolve, milliseconds));\r\n  };\r\n\r\n  /**\r\n   * generate random number array\r\n   * @param length length of array\r\n   * @param min min value\r\n   * @param max max value\r\n   */\r\n  public static generateRandomArray(\r\n    length: number,\r\n    min: number,\r\n    max: number\r\n  ): number[] {\r\n    return Array.from(\r\n      {\r\n        length: length,\r\n      },\r\n      () => UtilityHelper.getRamdonNumber(min, max)\r\n    );\r\n  }\r\n}\r\n\r\nexport default UtilityHelper;\r\n","import * as enums from \"../enums\";\r\nimport * as constants from \"../constants\";\r\nimport UtilityHelper from \"./utilityhelper\";\r\nimport Node from \"../components/grid/typings/node\";\r\nimport DropdownOption from \"../components/common/typings/dropdownoption\";\r\n\r\nclass NodeHelper {\r\n  /**\r\n   * return sorting speed\r\n   */\r\n  public static getAnimationSpeed = (index: number) => {\r\n    let speed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\r\n    return speed[index - 1];\r\n  };\r\n\r\n  /**\r\n   * return start and destination node poistion.\r\n   */\r\n  public static getDefaultNodePosition = () => {\r\n    let startRow = UtilityHelper.getRamdonNumber(1, 19);\r\n    let startColumn = UtilityHelper.getRamdonNumber(1, 11);\r\n    let destinationRow = UtilityHelper.getRamdonNumber(1, 19);\r\n    let destinationColumn = UtilityHelper.getRamdonNumber(40, 49);\r\n\r\n    return [\r\n      [startRow, startColumn],\r\n      [destinationRow, destinationColumn],\r\n    ];\r\n\r\n    /*return [\r\n      [9, 11],\r\n      [9, 40],\r\n    ];*/\r\n  };\r\n\r\n  /**\r\n   * create a node\r\n   */\r\n  public static createNode = (\r\n    row: number,\r\n    column: number,\r\n    defaultNodePosition: number[][]\r\n  ) => {\r\n    const startRow = defaultNodePosition[0][0];\r\n    const startColumn = defaultNodePosition[0][1];\r\n    const destinationRow = defaultNodePosition[1][0];\r\n    const destinationColumn = defaultNodePosition[1][1];\r\n\r\n    let node: Node = {\r\n      row: row,\r\n      column: column,\r\n      distance: Infinity,\r\n      previousNode: undefined,\r\n      isVisited: false,\r\n      isBrick: false,\r\n      isStart: row === startRow && column === startColumn,\r\n      isDestination: row === destinationRow && column === destinationColumn,\r\n    };\r\n\r\n    return node;\r\n  };\r\n\r\n  /**\r\n   * Initialize nodes\r\n   */\r\n  public static initNodes = (\r\n    numberOfRows: number,\r\n    numberOfColumns: number,\r\n    defaultNodePosition: number[][]\r\n  ) => {\r\n    let nodes: Node[][] = [];\r\n\r\n    for (let row = 0; row < numberOfRows; row++) {\r\n      let newRow: Node[] = [];\r\n\r\n      for (let column = 0; column < numberOfColumns; column++) {\r\n        let node = NodeHelper.createNode(row, column, defaultNodePosition);\r\n        newRow.push(node);\r\n      }\r\n\r\n      nodes.push(newRow);\r\n    }\r\n\r\n    return nodes;\r\n  };\r\n\r\n  /**\r\n   * return true if element has destination class\r\n   * @param element element\r\n   */\r\n  public static isDestinationNode(element: Element) {\r\n    return element.classList.contains(constants.NodeClass.destination);\r\n  }\r\n\r\n  /**\r\n   * return true if element has start class\r\n   * @param element element\r\n   */\r\n  public static isStartNode(element: Element) {\r\n    return element.classList.contains(constants.NodeClass.start);\r\n  }\r\n\r\n  /**\r\n   * return true if element has node class\r\n   * @param element element\r\n   */\r\n  public static isNode(element: Element) {\r\n    return element.classList.contains(constants.NodeClass.node);\r\n  }\r\n\r\n  /**\r\n   * toggle brick class\r\n   * @param element html element\r\n   */\r\n  public static toggleBrick(element: HTMLElement, grid: Node[][]) {\r\n    if (\r\n      element &&\r\n      NodeHelper.isNode(element) &&\r\n      !NodeHelper.isStartNode(element) &&\r\n      !NodeHelper.isDestinationNode(element)\r\n    ) {\r\n      let position = NodeHelper.getNodePositionFromElemet(element);\r\n      let node = grid[position[0]][position[1]];\r\n      node.isBrick = !node.isBrick;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * return node type of element\r\n   * @param element  element\r\n   */\r\n  public static getNodeType(element: Element) {\r\n    let type = enums.NodeType.None;\r\n\r\n    if (element) {\r\n      let classList = element.classList;\r\n\r\n      if (classList.contains(constants.NodeClass.start)) {\r\n        type = enums.NodeType.Start;\r\n      } else if (classList.contains(constants.NodeClass.destination)) {\r\n        type = enums.NodeType.Destination;\r\n      }\r\n    }\r\n\r\n    return type;\r\n  }\r\n\r\n  /**\r\n   * return css class for a node\r\n   * @param nodeType node type\r\n   */\r\n  public static getNodeClass(nodeType: enums.NodeType) {\r\n    let className = \"\";\r\n\r\n    switch (nodeType) {\r\n      case enums.NodeType.Start:\r\n        className = constants.NodeClass.start;\r\n        break;\r\n      case enums.NodeType.Destination:\r\n        className = constants.NodeClass.destination;\r\n        break;\r\n    }\r\n\r\n    return className;\r\n  }\r\n\r\n  /**\r\n   * get node position from element id\r\n   * @param element element\r\n   */\r\n  public static getNodePositionFromElemet(element: Element) {\r\n    if (element) {\r\n      let id = element.id;\r\n      let idParts = id.split(\"-\");\r\n      return [parseInt(idParts[1]), parseInt(idParts[2])];\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * get node from DOM\r\n   * @param row row\r\n   * @param column column\r\n   */\r\n  public static getNodeFromDOM(row: number, column: number) {\r\n    return document.getElementById(`node-${row}-${column}`);\r\n  }\r\n\r\n  /**\r\n   * get algorithm options for dropdown\r\n   * @param selectedAlgorithm selected algorithm\r\n   */\r\n  public static getAlgorithmOptions(selectedAlgorithm: enums.Algorithm) {\r\n    let options: DropdownOption[] = [];\r\n\r\n    let none: DropdownOption = {\r\n      id: enums.Algorithm.Dijkstra,\r\n      value: NodeHelper.getAlgorithmName(enums.Algorithm.Dijkstra),\r\n      isSelected: false,\r\n    };\r\n\r\n    options.push(none);\r\n\r\n    for (let option of options) {\r\n      option.isSelected = option.id === selectedAlgorithm;\r\n    }\r\n\r\n    return options;\r\n  }\r\n\r\n  /**\r\n   * get algorithm name\r\n   * @param type algorithm type\r\n   */\r\n  public static getAlgorithmName(type: enums.Algorithm) {\r\n    let name = \"\";\r\n\r\n    switch (type) {\r\n      case enums.Algorithm.Dijkstra:\r\n        name = \"Dijkstra's\";\r\n        break;\r\n    }\r\n\r\n    return name;\r\n  }\r\n}\r\n\r\nexport default NodeHelper;\r\n","import React from \"react\";\r\nimport * as enums from \"../../enums\";\r\nimport Dropdown from \"../common/dropdown\";\r\nimport DropdownOption from \"../common/typings/dropdownoption\";\r\nimport TerrainHelper from \"../../helper/terrainhelper\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\n\r\ninterface Props {\r\n  onVisualizeClick: (\r\n    e: React.MouseEvent<HTMLButtonElement, MouseEvent>\r\n  ) => void;\r\n  onResetStage: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\r\n  onSpeedChange: (e: React.ChangeEvent<HTMLElement>) => void;\r\n  onAlgorithmSelected: (option: DropdownOption) => void;\r\n  onTerrainOptionSelected: (option: DropdownOption) => void;\r\n  selectedTerrain: enums.TerrainType;\r\n  selectedAlgorithm: enums.Algorithm;\r\n  isPathFindingInProgress: boolean;\r\n}\r\n\r\nconst StageControls: React.FunctionComponent<Props> = (props) => {\r\n  const speedRangeOptions = {\r\n    min: 1,\r\n    max: 10,\r\n    default: 5,\r\n  };\r\n\r\n  return (\r\n    <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark\">\r\n      <span className=\"navbar-brand title\">Shortest path algorithm</span>\r\n      <button\r\n        className=\"navbar-toggler\"\r\n        type=\"button\"\r\n        data-toggle=\"collapse\"\r\n        data-target=\"#navbarSupportedContent\"\r\n        aria-controls=\"navbarSupportedContent\"\r\n        aria-expanded=\"false\"\r\n        aria-label=\"Toggle navigation\"\r\n      >\r\n        <span className=\"navbar-toggler-icon\"></span>\r\n      </button>\r\n\r\n      <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n        <ul className=\"navbar-nav mr-auto\">\r\n          <Dropdown\r\n            id=\"algorithm-dropdown\"\r\n            disabled={props.isPathFindingInProgress}\r\n            onOptionSelected={props.onAlgorithmSelected}\r\n            options={NodeHelper.getAlgorithmOptions(props.selectedAlgorithm)}\r\n          />\r\n          <Dropdown\r\n            id=\"terrain-dropdown\"\r\n            classname=\"terrain-selected-item\"\r\n            disabled={props.isPathFindingInProgress}\r\n            onOptionSelected={props.onTerrainOptionSelected}\r\n            options={TerrainHelper.getTerrainOption(props.selectedTerrain)}\r\n          />\r\n          <li className=\"nav-item\">\r\n            &nbsp;&nbsp;&nbsp;&nbsp;\r\n            <button\r\n              className=\"btn btn-success\"\r\n              onClick={props.onVisualizeClick}\r\n              disabled={props.isPathFindingInProgress}\r\n            >\r\n              Visualize\r\n            </button>\r\n          </li>\r\n          <li className=\"nav-item dropdown\">\r\n            &nbsp;&nbsp;&nbsp;&nbsp;\r\n            <button\r\n              className=\"btn btn-warning\"\r\n              onClick={props.onResetStage}\r\n              disabled={props.isPathFindingInProgress}\r\n            >\r\n              Reset\r\n            </button>\r\n          </li>\r\n          <li className=\"range\">\r\n            <p>Visualizing speed</p>\r\n            <input\r\n              type=\"range\"\r\n              min={speedRangeOptions.min}\r\n              max={speedRangeOptions.max}\r\n              defaultValue={speedRangeOptions.default}\r\n              onChange={props.onSpeedChange}\r\n            />\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </nav>\r\n  );\r\n};\r\n\r\nexport default StageControls;\r\n","import React from \"react\";\r\nimport classNames from \"classnames\";\r\nimport * as constants from \"../../constants\";\r\n\r\nconst NodeDescriptor: React.FunctionComponent = () => {\r\n  /**\r\n   * get node descriptor\r\n   * @param id id of descriptor\r\n   * @param text text to display\r\n   * @param classNames classnames to add\r\n   */\r\n  const getDescripor = (id: string, text: string, classNames: string) => {\r\n    return (\r\n      <div id={id} className=\"descriptor\">\r\n        <div className={classNames} />\r\n        &nbsp;\r\n        <span>{text}</span>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  const cssClass = constants.NodeClass;\r\n\r\n  return (\r\n    <div className=\"grid-descriptor\">\r\n      {getDescripor(\r\n        \"startNode\",\r\n        \"Start Node\",\r\n        classNames(cssClass.node, cssClass.start)\r\n      )}\r\n      {getDescripor(\r\n        \"destinationNode\",\r\n        \"Destination Node\",\r\n        classNames(cssClass.node, cssClass.destination)\r\n      )}\r\n      {getDescripor(\r\n        \"pathNode\",\r\n        \"Path Node\",\r\n        classNames(cssClass.node, cssClass.path)\r\n      )}\r\n      {getDescripor(\r\n        \"unvisitedNode\",\r\n        \"Unvisited Node\",\r\n        classNames(cssClass.node)\r\n      )}\r\n      {getDescripor(\r\n        \"visitedNode\",\r\n        \"Visited Node\",\r\n        classNames(cssClass.node, cssClass.visited)\r\n      )}\r\n      {getDescripor(\r\n        \"brickNode\",\r\n        \"Brick Node\",\r\n        classNames(cssClass.node, cssClass.brick)\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NodeDescriptor;\r\n","import ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport UtilityHelper from \"../../helper/utilityhelper\";\r\n\r\nclass RandomTerrain implements ITerrainGenerator {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * get terrain\r\n   */\r\n  public getTerrain(): number[][] {\r\n    let terrain: number[][] = [];\r\n\r\n    for (let row of this.nodes) {\r\n      terrain.push(UtilityHelper.generateRandomArray(10, 0, row.length - 1));\r\n    }\r\n\r\n    return terrain;\r\n  }\r\n}\r\n\r\nexport default RandomTerrain;\r\n","import ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport UtilityHelper from \"../../helper/utilityhelper\";\r\n\r\nclass RecursiveDivision implements ITerrainGenerator {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * Divide grid\r\n   * @param terrain terrain\r\n   * @param rowStart row start\r\n   * @param rowEnd row end\r\n   * @param colStart column start\r\n   * @param colEnd column end\r\n   */\r\n  private divide(\r\n    terrain: number[][],\r\n    rowStart: number,\r\n    rowEnd: number,\r\n    colStart: number,\r\n    colEnd: number\r\n  ) {\r\n    if (colEnd - colStart <= 0 || rowEnd - rowStart <= 0) {\r\n      return;\r\n    }\r\n\r\n    let width = colEnd - colStart + 1;\r\n    let height = rowEnd - rowStart + 1;\r\n\r\n    if (width <= height) {\r\n      // horizontal cut\r\n      let row = UtilityHelper.getRamdonNumber(rowStart, rowEnd);\r\n\r\n      for (let i = colStart; i <= colEnd; i++) {\r\n        // make a opening at column start\r\n        if (i === colStart) {\r\n          continue;\r\n        }\r\n\r\n        terrain[row].push(i);\r\n      }\r\n\r\n      this.divide(terrain, rowStart, row - 2, colStart, colEnd);\r\n      this.divide(terrain, row + 2, rowEnd, colStart, colEnd);\r\n    } else {\r\n      // vertical cut\r\n      let col = UtilityHelper.getRamdonNumber(colStart, colEnd);\r\n      let row = UtilityHelper.getRamdonNumber(rowStart, rowEnd);\r\n\r\n      for (let i = rowStart; i <= rowEnd; i++) {\r\n        // make a opening at row start\r\n        if (i === row) {\r\n          continue;\r\n        }\r\n\r\n        terrain[i].push(col);\r\n      }\r\n\r\n      this.divide(terrain, rowStart, rowEnd, colStart, col - 2);\r\n      this.divide(terrain, rowStart, rowEnd, col + 2, colEnd);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * get terrain\r\n   */\r\n  public getTerrain(): number[][] {\r\n    let terrain: number[][] = [];\r\n    let rowStart = 0;\r\n    let rowEnd = this.nodes.length - 1;\r\n    let colStart = 0;\r\n    let colEnd = this.nodes[0].length - 1;\r\n\r\n    this.nodes.forEach(() => {\r\n      terrain.push([]);\r\n    });\r\n\r\n    this.divide(terrain, rowStart, rowEnd, colStart, colEnd);\r\n\r\n    return terrain;\r\n  }\r\n}\r\n\r\nexport default RecursiveDivision;\r\n","import ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\nclass DiagonalLineTerrain implements ITerrainGenerator {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * get terrain\r\n   */\r\n  public getTerrain(): number[][] {\r\n    let terrain: number[][] = [];\r\n    let row = 1;\r\n    let column = 1;\r\n\r\n    for (let i = 0; i < 18; i++) {\r\n      if (i > row) {\r\n        terrain.push([\r\n          row + i,\r\n          column + i,\r\n          row + i + 10,\r\n          column + i + 10,\r\n          row + i + 20,\r\n          column + i + 20,\r\n          row + i + 30,\r\n          column + i + 30,\r\n        ]);\r\n      } else {\r\n        terrain.push([]);\r\n      }\r\n    }\r\n\r\n    return terrain;\r\n  }\r\n}\r\n\r\nexport default DiagonalLineTerrain;\r\n","import * as enums from \"../../enums\";\r\nimport RandomTerrain from \"./randomterrain\";\r\nimport RecursiveDivision from \"./recursivedivision\";\r\nimport ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport DiagonalLineTerrain from \"./diagonallineterrain\";\r\n\r\nclass TerrainEngine {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * set terrain i grid\r\n   * @param terrainType terrain type\r\n   */\r\n  public setTerrain(terrainType: enums.TerrainType) {\r\n    let terrainGenerator: ITerrainGenerator;\r\n\r\n    try {\r\n      switch (terrainType) {\r\n        case enums.TerrainType.RandomBricks:\r\n          terrainGenerator = new RandomTerrain(this.nodes);\r\n          break;\r\n        case enums.TerrainType.DiagonalLines:\r\n          terrainGenerator = new DiagonalLineTerrain(this.nodes);\r\n          break;\r\n        case enums.TerrainType.RecursiveDivision:\r\n          terrainGenerator = new RecursiveDivision(this.nodes);\r\n          break;\r\n        default:\r\n          throw new Error(\"Terrain not found :|\");\r\n      }\r\n\r\n      let terrain = terrainGenerator.getTerrain();\r\n      this.mapTerrainToNodes(this.nodes, terrain);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * map terrain to nodes\r\n   * @param nodes nodes\r\n   * @param terrain terrain\r\n   */\r\n  private mapTerrainToNodes(nodes: Node[][], terrain: number[][]) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      let row = nodes[i];\r\n      let terrainRow = terrain[i];\r\n      for (let j = 0; j < terrainRow.length; j++) {\r\n        let node = row[terrainRow[j]];\r\n        if (!node.isStart && !node.isDestination) {\r\n          row[terrainRow[j]].isBrick = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default TerrainEngine;\r\n","import IPathFinder from \"./ipathfinder\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\nclass Dijkstra implements IPathFinder {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * find shortest path\r\n   */\r\n  public find = (startNode: Node, destinationNode: Node) => {\r\n    let visitedNodes: Node[] = [];\r\n    let unvisitedNodes: Node[] = [];\r\n\r\n    // distance to start node is 0\r\n    startNode.distance = 0;\r\n    // get all nodes\r\n    unvisitedNodes = this.flatten2DNodeArray(this.nodes);\r\n\r\n    while (!!unvisitedNodes.length) {\r\n      this.sortNodeByDistance(unvisitedNodes);\r\n      let adjacentNode = unvisitedNodes.shift();\r\n      if (adjacentNode) {\r\n        if (adjacentNode.isBrick) {\r\n          continue;\r\n        }\r\n\r\n        if (adjacentNode.distance === Infinity) {\r\n          break;\r\n        }\r\n\r\n        adjacentNode.isVisited = true;\r\n        visitedNodes.push(adjacentNode);\r\n\r\n        if (adjacentNode === destinationNode) {\r\n          break;\r\n        }\r\n\r\n        this.updateDistanceOfUnvisitedNeighbors(adjacentNode, this.nodes);\r\n      }\r\n    }\r\n\r\n    const nodesInShortestPath: Node[] = [];\r\n    let currentNode = destinationNode;\r\n    while (currentNode) {\r\n      nodesInShortestPath.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return [visitedNodes, nodesInShortestPath];\r\n  };\r\n\r\n  private updateDistanceOfUnvisitedNeighbors(node: Node, grid: Node[][]) {\r\n    const unvisitedNeighbours = this.getUnvisitedNeighbors(node, grid);\r\n\r\n    for (const neighbor of unvisitedNeighbours) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n\r\n  private getUnvisitedNeighbors(node: Node, grid: Node[][]) {\r\n    const neighbors: Node[] = [];\r\n    const { row, column } = node;\r\n\r\n    if (row > 0) {\r\n      neighbors.push(grid[row - 1][column]);\r\n    }\r\n    if (row < grid.length - 1) {\r\n      neighbors.push(grid[row + 1][column]);\r\n    }\r\n    if (column > 0) {\r\n      neighbors.push(grid[row][column - 1]);\r\n    }\r\n    if (column < grid[0].length - 1) {\r\n      neighbors.push(grid[row][column + 1]);\r\n    }\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n  }\r\n\r\n  /**\r\n   * return nodes in sorted order based on distance\r\n   * @param nodes nodes\r\n   */\r\n  private sortNodeByDistance(nodes: Node[]) {\r\n    nodes.sort((a: Node, b: Node) => a.distance - b.distance);\r\n  }\r\n\r\n  /**\r\n   * flatten 2D grid to array of nodes\r\n   * @param grid grid\r\n   */\r\n  private flatten2DNodeArray(grid: Node[][]) {\r\n    let nodes: Node[] = [];\r\n\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n}\r\n\r\nexport default Dijkstra;\r\n","import Dijkstra from \"./dijkstra\";\r\nimport * as enums from \"../../enums\";\r\nimport IPathFinder from \"./ipathfinder\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport PathFindingOptions from \"./pathfindingoptions\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport UtilityHelper from \"../../helper/utilityhelper\";\r\n\r\nclass PathFindingEngine {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  // path finding options\r\n  private options: PathFindingOptions;\r\n\r\n  constructor(nodes: Node[][], options: PathFindingOptions) {\r\n    this.nodes = nodes;\r\n    this.options = options;\r\n  }\r\n\r\n  /**\r\n   * find shortest path\r\n   * @param startNode start node\r\n   * @param destinationNode destination node1\r\n   * @param algorithm selected algorithm\r\n   */\r\n  public find = async (\r\n    startNode: Node,\r\n    destinationNode: Node,\r\n    algorithm: enums.Algorithm\r\n  ) => {\r\n    let pathFinder: IPathFinder;\r\n\r\n    switch (algorithm) {\r\n      case enums.Algorithm.Dijkstra:\r\n        pathFinder = new Dijkstra(this.nodes);\r\n        break;\r\n    }\r\n\r\n    const [visitedNodes, nodesInShortestPath] = pathFinder.find(\r\n      startNode,\r\n      destinationNode\r\n    );\r\n\r\n    await this.animate(visitedNodes, nodesInShortestPath);\r\n  };\r\n\r\n  private animate = async (\r\n    visitedNodes: Node[],\r\n    nodesInShortestPath: Node[]\r\n  ) => {\r\n    for (let i = 0; i < visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length - 1) {\r\n        for (let j = 0; j < nodesInShortestPath.length; j++) {\r\n          const node = nodesInShortestPath[j];\r\n          if (!this.isStartOrDestination(node)) {\r\n            let nodeElement = NodeHelper.getNodeFromDOM(node.row, node.column);\r\n            nodeElement?.classList.remove(\"visited\");\r\n            nodeElement?.classList.add(\"path\");\r\n\r\n            await UtilityHelper.sleep(this.options.getAnimationSpeed());\r\n          }\r\n        }\r\n      }\r\n\r\n      const node = visitedNodes[i];\r\n      if (!this.isStartOrDestination(node)) {\r\n        let nodeElement = NodeHelper.getNodeFromDOM(node.row, node.column);\r\n        nodeElement?.classList.add(\"visited\");\r\n      }\r\n\r\n      await UtilityHelper.sleep(this.options.getAnimationSpeed());\r\n    }\r\n  };\r\n\r\n  /**\r\n   * return true if node is start or destination\r\n   * @param node node\r\n   */\r\n  private isStartOrDestination(node: Node) {\r\n    return node.isStart || node.isDestination;\r\n  }\r\n}\r\n\r\nexport default PathFindingEngine;\r\n","import React from \"react\";\r\nimport Grid from \"../grid/grid\";\r\nimport * as enums from \"../../enums\";\r\nimport Node from \"../grid/typings/node\";\r\nimport settings from \"../../appsettings\";\r\nimport StageControls from \"./stagecontrols\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport NodeDescriptor from \"../grid/nodedescriptor\";\r\nimport TerrainHelper from \"../../helper/terrainhelper\";\r\nimport DropdownOption from \"../common/typings/dropdownoption\";\r\nimport TerrainEngine from \"../../algorithms/terrain/terrainengine\";\r\nimport PathFindingEngine from \"../../algorithms/pathfinding/pathfindingengine\";\r\nimport PathFindingOptions from \"../../algorithms/pathfinding/pathfindingoptions\";\r\n\r\ninterface State {\r\n  renderedOn: number;\r\n  renderNodes: boolean;\r\n}\r\n\r\ninterface Props {}\r\n\r\nclass Stage extends React.Component<Props, State> {\r\n  // number of rows in grid\r\n  private numberOfRows = 20;\r\n\r\n  // number of columns in a row\r\n  private numberOfColumns = 50;\r\n\r\n  // holds currently dragged node type\r\n  private draggedNodeType = enums.NodeType.None;\r\n\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  // selected path finding algorithm\r\n  private selectedAlgorithm = enums.Algorithm.Dijkstra;\r\n\r\n  // holds node position.\r\n  private nodePositions: number[][] = [];\r\n\r\n  // selected terrain\r\n  private selectedTerrain = enums.TerrainType.None;\r\n\r\n  // holds boolean flag for pan started or not\r\n  private isPanStarted = false;\r\n\r\n  // holds flag if path fining is in progress or not\r\n  private isPathFindingInProgress = false;\r\n\r\n  // hold defult animation speed\r\n  private animationSpeed: number = settings.animationSpeed.default;\r\n\r\n  /**\r\n   * constructor for stage component\r\n   */\r\n  constructor(props: Props, state: State) {\r\n    super(props, state);\r\n    this.state = {\r\n      renderedOn: 0,\r\n      renderNodes: true,\r\n    };\r\n    this.resetStage(enums.TerrainType.None, false);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"stage\">\r\n        <StageControls\r\n          onSpeedChange={this.onSpeedChange}\r\n          onResetStage={this.onResetStage}\r\n          onVisualizeClick={this.onVisualizeClick}\r\n          onTerrainOptionSelected={this.onTerrainOptionSelected}\r\n          selectedTerrain={this.selectedTerrain}\r\n          onAlgorithmSelected={this.onAlgorithmOptionSelected}\r\n          selectedAlgorithm={this.selectedAlgorithm}\r\n          isPathFindingInProgress={this.isPathFindingInProgress}\r\n        />\r\n        <NodeDescriptor />\r\n        {this.state.renderNodes ? (\r\n          <Grid\r\n            id=\"grid\"\r\n            nodes={this.nodes}\r\n            onNodeDropEnd={this.onNodeDropEnd}\r\n            onNodeDragStart={this.onNodeDragStart}\r\n            onNodeMouseEnter={this.onNodeMouseEnter}\r\n            onGridContainerMouseUp={this.onGridContainerMouseUp}\r\n            onGridContainerMouseDown={this.onGridContainerMouseDown}\r\n            isPathFindingInProgress={this.isPathFindingInProgress}\r\n          />\r\n        ) : null}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * set animation speed\r\n   * @param index index of speed\r\n   */\r\n  private setAnimationSpeed = (index = 0) => {\r\n    this.animationSpeed = NodeHelper.getAnimationSpeed(\r\n      index === 0 ? settings.animationSpeed.default : index\r\n    );\r\n  };\r\n\r\n  /**\r\n   * get animation speed\r\n   */\r\n  private getAnimationSpeed = () => {\r\n    return this.animationSpeed;\r\n  };\r\n\r\n  /**\r\n   * on animation speed change\r\n   * @param event event\r\n   */\r\n  private onSpeedChange = (event: React.ChangeEvent<HTMLElement>) => {\r\n    let target: any = event.target;\r\n    let weight = parseInt(target.value);\r\n    this.setAnimationSpeed(weight);\r\n  };\r\n\r\n  /**\r\n   * mouse up event for grid container\r\n   */\r\n  private onGridContainerMouseUp = (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => {\r\n    this.isPanStarted = false;\r\n  };\r\n\r\n  /**\r\n   * mouse down event for grid container\r\n   */\r\n  private onGridContainerMouseDown = (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => {\r\n    let target: any = e.target;\r\n    this.isPanStarted = true;\r\n    NodeHelper.toggleBrick(target, this.nodes);\r\n    this.setState({ renderedOn: Date.now() });\r\n  };\r\n\r\n  /**\r\n   * on mouse enter of node\r\n   */\r\n  private onNodeMouseEnter = (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => {\r\n    if (this.isPanStarted) {\r\n      let target: any = e.target;\r\n      NodeHelper.toggleBrick(target, this.nodes);\r\n      this.setState({ renderedOn: Date.now() });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when algorithm option is selected\r\n   */\r\n  private onAlgorithmOptionSelected = (option: DropdownOption) => {\r\n    if (this.selectedAlgorithm !== option.id) {\r\n      this.selectedAlgorithm = option.id;\r\n      this.setState({ renderedOn: Date.now() });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when terrain option is selected\r\n   */\r\n  private onTerrainOptionSelected = (option: DropdownOption) => {\r\n    if (this.selectedTerrain !== option.id) {\r\n      // reset stage on terrain change\r\n      this.resetStage(option.id, false);\r\n\r\n      this.setState({ renderNodes: false }, () => {\r\n        if (this.selectedTerrain !== enums.TerrainType.None) {\r\n          const terrainEngine = new TerrainEngine(this.nodes);\r\n          terrainEngine.setTerrain(this.selectedTerrain);\r\n        }\r\n\r\n        this.setState({ renderNodes: true });\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when visualize button is clicked\r\n   */\r\n  private onResetStage = async (\r\n    e: React.MouseEvent<HTMLButtonElement, MouseEvent>\r\n  ) => {\r\n    this.resetStage(enums.TerrainType.None);\r\n  };\r\n\r\n  /**\r\n   * triggered when visualize button is clicked\r\n   */\r\n  private onVisualizeClick = async (\r\n    e: React.MouseEvent<HTMLButtonElement, MouseEvent>\r\n  ) => {\r\n    this.isPathFindingInProgress = true;\r\n    this.setState({ renderedOn: Date.now() });\r\n\r\n    const startRow = this.nodePositions[0][0];\r\n    const startColumn = this.nodePositions[0][1];\r\n    const destinationRow = this.nodePositions[1][0];\r\n    const destinationColumn = this.nodePositions[1][1];\r\n\r\n    let startNode = this.nodes[startRow][startColumn];\r\n    startNode.isStart = true;\r\n\r\n    let destinationNode = this.nodes[destinationRow][destinationColumn];\r\n    destinationNode.isDestination = true;\r\n\r\n    let options: PathFindingOptions = {\r\n      getAnimationSpeed: this.getAnimationSpeed,\r\n    };\r\n\r\n    let pathfindingEngine = new PathFindingEngine(this.nodes, options);\r\n    await pathfindingEngine.find(\r\n      startNode,\r\n      destinationNode,\r\n      this.selectedAlgorithm\r\n    );\r\n\r\n    this.isPathFindingInProgress = false;\r\n    this.setState({ renderedOn: Date.now() });\r\n  };\r\n\r\n  /**\r\n   * triggered when a node is dragged\r\n   */\r\n  private onNodeDragStart = (e: React.DragEvent<HTMLDivElement>) => {\r\n    let target: any = e.target;\r\n    if (\r\n      NodeHelper.isNode(target) &&\r\n      (NodeHelper.isStartNode(target) || NodeHelper.isDestinationNode(target))\r\n    ) {\r\n      let nodeType = NodeHelper.getNodeType(target);\r\n      this.draggedNodeType = nodeType;\r\n\r\n      let cssClass = NodeHelper.getNodeClass(nodeType);\r\n      target.classList.remove(cssClass);\r\n      target.setAttribute(\"draggable\", \"false\");\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when node drop\r\n   */\r\n  private onNodeDropEnd = (e: React.DragEvent<HTMLDivElement>) => {\r\n    let element: any = e.target;\r\n    let x = e.clientX;\r\n    let y = e.clientY;\r\n    let currentElement = document.elementFromPoint(x, y);\r\n    let cssClass = NodeHelper.getNodeClass(this.draggedNodeType);\r\n    if (cssClass !== \"\") {\r\n      if (\r\n        currentElement &&\r\n        NodeHelper.isNode(currentElement) &&\r\n        !NodeHelper.isStartNode(currentElement) &&\r\n        !NodeHelper.isDestinationNode(currentElement)\r\n      ) {\r\n        element = currentElement;\r\n      }\r\n      element.classList.add(cssClass);\r\n      element.setAttribute(\"draggable\", \"true\");\r\n\r\n      let newPosition = NodeHelper.getNodePositionFromElemet(element);\r\n      if (newPosition) {\r\n        if (this.draggedNodeType === enums.NodeType.Start) {\r\n          this.nodePositions[0] = newPosition;\r\n        } else if (this.draggedNodeType === enums.NodeType.Destination) {\r\n          this.nodePositions[1] = newPosition;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.draggedNodeType = enums.NodeType.None;\r\n    this.isPanStarted = false;\r\n  };\r\n\r\n  /**\r\n   * reset stage\r\n   */\r\n  private resetStage = (\r\n    terrain: enums.TerrainType,\r\n    doRerenderNodes: boolean = true\r\n  ) => {\r\n    this.selectedTerrain = terrain;\r\n    this.nodePositions = NodeHelper.getDefaultNodePosition();\r\n    this.nodes = NodeHelper.initNodes(\r\n      this.numberOfRows,\r\n      this.numberOfColumns,\r\n      this.nodePositions\r\n    );\r\n\r\n    if (doRerenderNodes) {\r\n      this.setState({ renderNodes: false }, () => {\r\n        setTimeout(() => {\r\n          this.setState({ renderNodes: true });\r\n        }, 0);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\nexport default Stage;\r\n","import React from \"react\";\nimport Stage from \"./components/stage/stage\";\n\nfunction App() {\n  return <Stage />;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}