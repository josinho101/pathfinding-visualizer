{"version":3,"sources":["enums/index.ts","components/grid/grid.tsx","components/stage/stagefooter.tsx","appsettings.js","components/common/dropdown.tsx","helper/terrainhelper.ts","constants/index.ts","helper/utilityhelper.ts","helper/nodehelper.ts","components/stage/stagecontrols.tsx","components/grid/nodedescriptor.tsx","algorithms/terrain/randomterrain.ts","algorithms/terrain/recursivedivision.ts","algorithms/terrain/diagonallineterrain.ts","algorithms/terrain/terrainengine.ts","algorithms/pathfinding/bfs.ts","algorithms/pathfinding/dfs.ts","algorithms/pathfinding/astar.ts","algorithms/pathfinding/dijkstra.ts","algorithms/pathfinding/pathfindingengine.ts","components/stage/stage.tsx","App.tsx","index.tsx"],"names":["NodeType","Algorithm","TerrainType","Grid","props","getColumn","node","identifier","row","column","id","key","draggable","isStart","isDestination","className","classNames","start","destination","brick","isBrick","onMouseEnter","onNodeMouseEnter","onDragStart","onNodeDragStart","onDragEnd","onNodeDropEnd","onDragOver","e","preventDefault","getRow","nodes","isPathFindingInProgress","onMouseDown","onGridContainerMouseDown","onMouseUp","onGridContainerMouseUp","rows","length","nodesArray","columns","push","rowId","jsxRow","generateGrid","StageFooter","algorithm","description","Fragment","enums","Dijkstra","Bfs","Dfs","AStar","getDescription","selectedAlgorithm","settings","animationSpeed","min","max","default","Dropdown","classname","disabled","href","role","data-toggle","aria-haspopup","aria-expanded","selectedItem","options","filter","item","isSelected","value","getSelectedItemText","aria-labelledby","map","option","onClick","onOptionSelected","TerrainHelper","type","name","None","RandomBricks","DiagonalLines","RecursiveDivision","getTerrainOption","selectedTerrain","none","getTerrainName","recursiveDivision","randomBricks","JTerrain","NodeClass","path","visited","UtilityHelper","Math","floor","random","Array","from","getRamdonNumber","sleep","milliseconds","Promise","resolve","setTimeout","NodeHelper","element","classList","contains","constants","grid","isNode","isStartNode","isDestinationNode","position","getNodePositionFromElemet","Start","Destination","nodeType","idParts","split","parseInt","document","getElementById","dijkstra","getAlgorithmName","aStar","bfs","dfs","nodesInShortestPath","currentNode","unshift","previousNode","neighbors","neighbor","isVisited","getAnimationSpeed","index","getDefaultNodePosition","createNode","defaultNodePosition","startRow","startColumn","destinationRow","destinationColumn","distance","Infinity","undefined","initNodes","numberOfRows","numberOfColumns","newRow","StageControls","speedRangeOptions","data-target","aria-controls","aria-label","onAlgorithmSelected","getAlgorithmOptions","onTerrainOptionSelected","onVisualizeClick","onResetStage","defaultValue","onChange","onSpeedChange","NodeDescriptor","getDescripor","text","cssClass","RandomTerrain","this","terrain","generateRandomArray","rowStart","rowEnd","colStart","colEnd","i","divide","col","forEach","DiagonalLineTerrain","TerrainEngine","terrainType","terrainGenerator","Error","getTerrain","mapTerrainToNodes","console","error","terrainRow","j","startNode","destinationNode","queue","visitedNodes","current","shift","unvisitedNodes","getUnvisitedNeighbors","nieghbour","getNodesAsPath","stack","pop","neighbours","neighbour","mapAstarNodeToNode","astarNode","visitedAStarNodes","openSet","mapNodeToAStarNode","getStartAndDestination","goal","gScore","fScore","getHeuristicValue","sortNodeByFScore","getNeighbors","tentative_gScore","heuristicValue","indexOf","aStarPath","sort","a","b","node1","node2","abs","getEmptyAStartNode","rowItems","aStarNode","find","flatten2DNodeArray","sortNodeByDistance","adjacentNode","updateDistanceOfUnvisitedNeighbors","unvisitedNeighbours","PathFindingEngine","pathFinder","animate","isStartOrDestination","nodeElement","getNodeFromDOM","remove","add","Stage","state","draggedNodeType","nodePositions","isPanStarted","setAnimationSpeed","event","target","weight","toggleBrick","setState","renderedOn","Date","now","onAlgorithmOptionSelected","resetStage","renderNodes","setTerrain","pathfindingEngine","getNodeType","getNodeClass","setAttribute","x","clientX","y","clientY","currentElement","elementFromPoint","newPosition","updateStartOrDestinationNode","doRerenderNodes","React","Component","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8b0c65a6.chunk.js","sourcesContent":["/**\r\n * Enums for different nodes\r\n */\r\nexport enum NodeType {\r\n  None = 0,\r\n  Start = 1,\r\n  Destination = 2,\r\n  Path = 3,\r\n  UnVisited = 4,\r\n  Visited = 5,\r\n  Brick = 6,\r\n}\r\n\r\n/**\r\n * enum for path finding algorithms\r\n */\r\nexport enum Algorithm {\r\n  Dijkstra = 1,\r\n  Bfs = 2,\r\n  Dfs = 3,\r\n  AStar = 4,\r\n}\r\n\r\n/**\r\n * enum for different terrains\r\n */\r\nexport enum TerrainType {\r\n  None = 0,\r\n  RandomBricks = 1,\r\n  DiagonalLines = 2,\r\n  RecursiveDivision = 3,\r\n}\r\n","import React from \"react\";\r\nimport Node from \"./typings/node\";\r\nimport classNames from \"classnames\";\r\n\r\ninterface Props {\r\n  id: string;\r\n  nodes: Node[][];\r\n  isPathFindingInProgress: boolean;\r\n  onNodeDragStart: (e: React.DragEvent<HTMLDivElement>) => void;\r\n  onNodeDropEnd: (e: React.DragEvent<HTMLDivElement>) => void;\r\n  onNodeMouseEnter: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\r\n  onGridContainerMouseDown: (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => void;\r\n  onGridContainerMouseUp: (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => void;\r\n}\r\n\r\nconst Grid: React.FunctionComponent<Props> = (props) => {\r\n  const getColumn = (node: Node) => {\r\n    let identifier = `node-${node.row}-${node.column}`;\r\n    return (\r\n      <div\r\n        id={identifier}\r\n        key={identifier}\r\n        draggable={node.isStart || node.isDestination}\r\n        className={classNames(\r\n          \"node\",\r\n          { start: node.isStart },\r\n          { destination: node.isDestination },\r\n          { brick: node.isBrick }\r\n        )}\r\n        onMouseEnter={props.onNodeMouseEnter}\r\n        onDragStart={props.onNodeDragStart}\r\n        onDragEnd={props.onNodeDropEnd}\r\n        onDragOver={(e) => {\r\n          e.preventDefault();\r\n        }}\r\n      ></div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * return row of grid\r\n   */\r\n  const getRow = (id: string, nodes: JSX.Element[]) => {\r\n    return (\r\n      <div id={id} key={id} className=\"row\">\r\n        {[nodes]}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * generate grid\r\n   */\r\n  const generateGrid = (nodes: Node[][]) => {\r\n    let rows: JSX.Element[] = [];\r\n\r\n    for (let row = 0; row < nodes.length; row++) {\r\n      let nodesArray = nodes[row];\r\n      let columns: JSX.Element[] = [];\r\n\r\n      for (let column = 0; column < nodesArray.length; column++) {\r\n        columns.push(getColumn(nodesArray[column]));\r\n      }\r\n\r\n      let rowId = `row-${row}`;\r\n      let jsxRow = getRow(rowId, columns);\r\n\r\n      rows.push(jsxRow);\r\n    }\r\n\r\n    return rows;\r\n  };\r\n\r\n  return (\r\n    <div\r\n      id={props.id}\r\n      className={classNames(\"node-container\", {\r\n        \"block-mouse-events\": props.isPathFindingInProgress,\r\n      })}\r\n      onMouseDown={props.onGridContainerMouseDown}\r\n      onMouseUp={props.onGridContainerMouseUp}\r\n    >\r\n      {generateGrid(props.nodes)}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import React from \"react\";\r\nimport * as enums from \"../../enums\";\r\n\r\ninterface Props {\r\n  selectedAlgorithm: enums.Algorithm;\r\n}\r\n\r\nconst StageFooter: React.FunctionComponent<Props> = (props) => {\r\n  const getDijkstraDescription = () => {\r\n    return (\r\n      <span>\r\n        Dijkstra's algorithm can be used for finding <b>shortest path </b>\r\n        between nodes in a graph. It can be used in <b>weighted</b> and\r\n        <b> unweighted</b> graphs. Using <b> negatively weighted</b> edges\r\n        wont't guarantees shortest path. Weighted nodes not implemented in this\r\n        visualization example.\r\n      </span>\r\n    );\r\n  };\r\n\r\n  const getBfsDescription = () => {\r\n    return (\r\n      <span>\r\n        Breadth-first search (BFS) is a traversing algorithm where traversing\r\n        starts from a selected node (<b>starting node</b>) and traverse the\r\n        graph <b>layerwise</b> thus exploring the neighbour nodes. BFS won't\r\n        work on <b>weighted</b> graps. It <b>guarantees shortest path</b> on\r\n        unweighted graphs.\r\n      </span>\r\n    );\r\n  };\r\n\r\n  const getDfsDescription = () => {\r\n    return (\r\n      <span>\r\n        Depth-first search (DFS) is an algorithm for traversing tree or graph\r\n        data structures. The algorithm starts at the <b>root node</b> and\r\n        explores as far as possible along each branch before backtracking. DFS\r\n        won't work on <b>weighted</b> graps, and <b>won't guarantees </b>\r\n        shortest path.\r\n      </span>\r\n    );\r\n  };\r\n\r\n  const getAStarDescription = () => {\r\n    return (\r\n      <span>\r\n        A* ('A-star') is a graph traversal and path search algorithm, which is\r\n        often used in many fields of computer science due to its completeness,\r\n        optimality, and optimal efficiency. A* achieves better performance by\r\n        using <b>heuristics</b> to guide its search. A-star work on both\r\n        <b> weighted</b> and <b>unweighted</b> graps. This algorithm guarantees{\" \"}\r\n        <b>shortest path</b>.\r\n      </span>\r\n    );\r\n  };\r\n\r\n  /**\r\n   * return description\r\n   * @param algorithm algorithm\r\n   */\r\n  const getDescription = (algorithm: enums.Algorithm) => {\r\n    let description: JSX.Element = <React.Fragment />;\r\n    switch (algorithm) {\r\n      case enums.Algorithm.Dijkstra:\r\n        description = getDijkstraDescription();\r\n        break;\r\n      case enums.Algorithm.Bfs:\r\n        description = getBfsDescription();\r\n        break;\r\n      case enums.Algorithm.Dfs:\r\n        description = getDfsDescription();\r\n        break;\r\n      case enums.Algorithm.AStar:\r\n        description = getAStarDescription();\r\n        break;\r\n    }\r\n\r\n    return description;\r\n  };\r\n\r\n  return (\r\n    <div className=\"stage-footer\">\r\n      <span className=\"note\">Note: </span>\r\n      {getDescription(props.selectedAlgorithm)}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default StageFooter;\r\n","let settings = {\r\n  animationSpeed: {\r\n    min: 1,\r\n    max: 10,\r\n    default: 5,\r\n  },\r\n};\r\n\r\nexport default settings;\r\n","import React from \"react\";\r\nimport classNames from \"classnames\";\r\nimport DropdownOption from \"./typings/dropdownoption\";\r\n\r\ninterface Props {\r\n  id: string;\r\n  disabled?: boolean;\r\n  options: DropdownOption[];\r\n  classname?: string;\r\n  onOptionSelected: (option: DropdownOption) => void;\r\n}\r\n\r\nconst Dropdown: React.FunctionComponent<Props> = (props) => {\r\n  // get selected item text\r\n  const getSelectedItemText = () => {\r\n    let selectedItem = props.options.filter((item) => item.isSelected);\r\n    if (selectedItem) {\r\n      return selectedItem[0].value;\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * render all menu items\r\n   */\r\n  const renderMenuIems = () => {\r\n    return props.options.map((option: DropdownOption) => {\r\n      let id = `${props.id}-item-${option.id}`;\r\n      return (\r\n        <a\r\n          key={id}\r\n          id={id}\r\n          className=\"dropdown-item\"\r\n          href=\"#\"\r\n          onClick={() => {\r\n            props.onOptionSelected(option);\r\n          }}\r\n        >\r\n          {option.value}\r\n        </a>\r\n      );\r\n    });\r\n  };\r\n\r\n  return (\r\n    <li id={props.id} className=\"nav-item dropdown active\">\r\n      <a\r\n        className={classNames(\"nav-link dropdown-toggle\", props.classname, {\r\n          disabled: props.disabled,\r\n        })}\r\n        href=\"#\"\r\n        id=\"navbarDropdown\"\r\n        role=\"button\"\r\n        data-toggle=\"dropdown\"\r\n        aria-haspopup=\"true\"\r\n        aria-expanded=\"false\"\r\n      >\r\n        {getSelectedItemText()}\r\n      </a>\r\n      <div className=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\">\r\n        {renderMenuIems()}\r\n      </div>\r\n    </li>\r\n  );\r\n};\r\n\r\nexport default Dropdown;\r\n","import * as enums from \"../enums\";\r\nimport DropdownOption from \"../components/common/typings/dropdownoption\";\r\nimport Node from \"../components/grid/typings/node\";\r\n\r\nclass TerrainHelper {\r\n  /**\r\n   * get terrain dropdown options\r\n   */\r\n  public static getTerrainOption = (selectedTerrain: enums.TerrainType) => {\r\n    let options: DropdownOption[] = [];\r\n\r\n    let none: DropdownOption = {\r\n      id: enums.TerrainType.None,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.None),\r\n      isSelected: false,\r\n    };\r\n\r\n    let recursiveDivision: DropdownOption = {\r\n      id: enums.TerrainType.RecursiveDivision,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.RecursiveDivision),\r\n      isSelected: false,\r\n    };\r\n\r\n    let randomBricks: DropdownOption = {\r\n      id: enums.TerrainType.RandomBricks,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.RandomBricks),\r\n      isSelected: false,\r\n    };\r\n\r\n    let JTerrain: DropdownOption = {\r\n      id: enums.TerrainType.DiagonalLines,\r\n      value: TerrainHelper.getTerrainName(enums.TerrainType.DiagonalLines),\r\n      isSelected: false,\r\n    };\r\n\r\n    options.push(none);\r\n    options.push(recursiveDivision);\r\n    options.push(randomBricks);\r\n    options.push(JTerrain);\r\n\r\n    for (let option of options) {\r\n      option.isSelected = option.id === selectedTerrain;\r\n    }\r\n\r\n    return options;\r\n  };\r\n\r\n  /**\r\n   * get terrain name based on type\r\n   * @param type terrain type\r\n   */\r\n  public static getTerrainName(type: enums.TerrainType) {\r\n    let name = \"\";\r\n\r\n    switch (type) {\r\n      case enums.TerrainType.None:\r\n        name = \"Blank terrain\";\r\n        break;\r\n      case enums.TerrainType.RandomBricks:\r\n        name = \"Random bricks\";\r\n        break;\r\n      case enums.TerrainType.DiagonalLines:\r\n        name = \"Diagonal lines\";\r\n        break;\r\n      case enums.TerrainType.RecursiveDivision:\r\n        name = \"Recursive division\";\r\n        break;\r\n    }\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * set all nodes as non brick\r\n   * @param nodes nodes\r\n   */\r\n  public static removeAllBrickNode(nodes: Node[][]) {\r\n    for (const row of nodes) {\r\n      for (const column of row) {\r\n        column.isBrick = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default TerrainHelper;\r\n","let NodeClass = {\r\n  start: \"start\",\r\n  destination: \"destination\",\r\n  node: \"node\",\r\n  path: \"path\",\r\n  brick: \"brick\",\r\n  visited: \"visited\",\r\n};\r\n\r\nexport { NodeClass };\r\n","class UtilityHelper {\r\n  /**\r\n   * generate random numbers between min and max values\r\n   * @param min min value\r\n   * @param max max value\r\n   */\r\n  public static getRamdonNumber(min: number, max: number) {\r\n    return min + Math.floor(Math.random() * (max - min + 1));\r\n  }\r\n\r\n  /**\r\n   * sleep for the specified amount of time\r\n   */\r\n  public static sleep = (milliseconds: number) => {\r\n    return new Promise((resolve) => setTimeout(resolve, milliseconds));\r\n  };\r\n\r\n  /**\r\n   * generate random number array\r\n   * @param length length of array\r\n   * @param min min value\r\n   * @param max max value\r\n   */\r\n  public static generateRandomArray(\r\n    length: number,\r\n    min: number,\r\n    max: number\r\n  ): number[] {\r\n    return Array.from(\r\n      {\r\n        length: length,\r\n      },\r\n      () => UtilityHelper.getRamdonNumber(min, max)\r\n    );\r\n  }\r\n}\r\n\r\nexport default UtilityHelper;\r\n","import * as enums from \"../enums\";\r\nimport * as constants from \"../constants\";\r\nimport UtilityHelper from \"./utilityhelper\";\r\nimport Node from \"../components/grid/typings/node\";\r\nimport DropdownOption from \"../components/common/typings/dropdownoption\";\r\n\r\nclass NodeHelper {\r\n  /**\r\n   * return sorting speed\r\n   */\r\n  public static getAnimationSpeed = (index: number) => {\r\n    let speed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\r\n    return speed[index - 1];\r\n  };\r\n\r\n  /**\r\n   * return start and destination node poistion.\r\n   */\r\n  public static getDefaultNodePosition = () => {\r\n    let startRow = UtilityHelper.getRamdonNumber(1, 19);\r\n    let startColumn = UtilityHelper.getRamdonNumber(1, 11);\r\n    let destinationRow = UtilityHelper.getRamdonNumber(1, 19);\r\n    let destinationColumn = UtilityHelper.getRamdonNumber(40, 49);\r\n\r\n    return [\r\n      [startRow, startColumn],\r\n      [destinationRow, destinationColumn],\r\n    ];\r\n\r\n    /*return [\r\n      [9, 11],\r\n      [9, 40],\r\n    ];*/\r\n  };\r\n\r\n  /**\r\n   * create a node\r\n   */\r\n  public static createNode = (\r\n    row: number,\r\n    column: number,\r\n    defaultNodePosition: number[][]\r\n  ) => {\r\n    const startRow = defaultNodePosition[0][0];\r\n    const startColumn = defaultNodePosition[0][1];\r\n    const destinationRow = defaultNodePosition[1][0];\r\n    const destinationColumn = defaultNodePosition[1][1];\r\n\r\n    let node: Node = {\r\n      row: row,\r\n      column: column,\r\n      distance: Infinity,\r\n      previousNode: undefined,\r\n      isVisited: false,\r\n      isBrick: false,\r\n      isStart: row === startRow && column === startColumn,\r\n      isDestination: row === destinationRow && column === destinationColumn,\r\n    };\r\n\r\n    return node;\r\n  };\r\n\r\n  /**\r\n   * Initialize nodes\r\n   */\r\n  public static initNodes = (\r\n    numberOfRows: number,\r\n    numberOfColumns: number,\r\n    defaultNodePosition: number[][]\r\n  ) => {\r\n    let nodes: Node[][] = [];\r\n\r\n    for (let row = 0; row < numberOfRows; row++) {\r\n      let newRow: Node[] = [];\r\n\r\n      for (let column = 0; column < numberOfColumns; column++) {\r\n        let node = NodeHelper.createNode(row, column, defaultNodePosition);\r\n        newRow.push(node);\r\n      }\r\n\r\n      nodes.push(newRow);\r\n    }\r\n\r\n    return nodes;\r\n  };\r\n\r\n  /**\r\n   * return true if element has destination class\r\n   * @param element element\r\n   */\r\n  public static isDestinationNode(element: Element) {\r\n    return element.classList.contains(constants.NodeClass.destination);\r\n  }\r\n\r\n  /**\r\n   * return true if element has start class\r\n   * @param element element\r\n   */\r\n  public static isStartNode(element: Element) {\r\n    return element.classList.contains(constants.NodeClass.start);\r\n  }\r\n\r\n  /**\r\n   * return true if element has node class\r\n   * @param element element\r\n   */\r\n  public static isNode(element: Element) {\r\n    return element.classList.contains(constants.NodeClass.node);\r\n  }\r\n\r\n  /**\r\n   * toggle brick class\r\n   * @param element html element\r\n   */\r\n  public static toggleBrick(element: HTMLElement, grid: Node[][]) {\r\n    if (\r\n      element &&\r\n      NodeHelper.isNode(element) &&\r\n      !NodeHelper.isStartNode(element) &&\r\n      !NodeHelper.isDestinationNode(element)\r\n    ) {\r\n      let position = NodeHelper.getNodePositionFromElemet(element);\r\n      let node = grid[position[0]][position[1]];\r\n      node.isBrick = !node.isBrick;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * return node type of element\r\n   * @param element  element\r\n   */\r\n  public static getNodeType(element: Element) {\r\n    let type = enums.NodeType.None;\r\n\r\n    if (element) {\r\n      let classList = element.classList;\r\n\r\n      if (classList.contains(constants.NodeClass.start)) {\r\n        type = enums.NodeType.Start;\r\n      } else if (classList.contains(constants.NodeClass.destination)) {\r\n        type = enums.NodeType.Destination;\r\n      }\r\n    }\r\n\r\n    return type;\r\n  }\r\n\r\n  /**\r\n   * return css class for a node\r\n   * @param nodeType node type\r\n   */\r\n  public static getNodeClass(nodeType: enums.NodeType) {\r\n    let className = \"\";\r\n\r\n    switch (nodeType) {\r\n      case enums.NodeType.Start:\r\n        className = constants.NodeClass.start;\r\n        break;\r\n      case enums.NodeType.Destination:\r\n        className = constants.NodeClass.destination;\r\n        break;\r\n    }\r\n\r\n    return className;\r\n  }\r\n\r\n  /**\r\n   * get node position from element id\r\n   * @param element element\r\n   */\r\n  public static getNodePositionFromElemet(element: Element) {\r\n    if (element) {\r\n      let id = element.id;\r\n      let idParts = id.split(\"-\");\r\n      return [parseInt(idParts[1]), parseInt(idParts[2])];\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * get node from DOM\r\n   * @param row row\r\n   * @param column column\r\n   */\r\n  public static getNodeFromDOM(row: number, column: number) {\r\n    return document.getElementById(`node-${row}-${column}`);\r\n  }\r\n\r\n  /**\r\n   * get algorithm options for dropdown\r\n   * @param selectedAlgorithm selected algorithm\r\n   */\r\n  public static getAlgorithmOptions(selectedAlgorithm: enums.Algorithm) {\r\n    let options: DropdownOption[] = [];\r\n\r\n    let dijkstra: DropdownOption = {\r\n      id: enums.Algorithm.Dijkstra,\r\n      value: NodeHelper.getAlgorithmName(enums.Algorithm.Dijkstra),\r\n      isSelected: false,\r\n    };\r\n\r\n    let aStar: DropdownOption = {\r\n      id: enums.Algorithm.AStar,\r\n      value: NodeHelper.getAlgorithmName(enums.Algorithm.AStar),\r\n      isSelected: false,\r\n    };\r\n\r\n    let bfs: DropdownOption = {\r\n      id: enums.Algorithm.Bfs,\r\n      value: NodeHelper.getAlgorithmName(enums.Algorithm.Bfs),\r\n      isSelected: false,\r\n    };\r\n\r\n    let dfs: DropdownOption = {\r\n      id: enums.Algorithm.Dfs,\r\n      value: NodeHelper.getAlgorithmName(enums.Algorithm.Dfs),\r\n      isSelected: false,\r\n    };\r\n\r\n    options.push(dijkstra);\r\n    options.push(aStar);\r\n    options.push(bfs);\r\n    options.push(dfs);\r\n\r\n    for (let option of options) {\r\n      option.isSelected = option.id === selectedAlgorithm;\r\n    }\r\n\r\n    return options;\r\n  }\r\n\r\n  /**\r\n   * get algorithm name\r\n   * @param type algorithm type\r\n   */\r\n  public static getAlgorithmName(type: enums.Algorithm) {\r\n    let name = \"\";\r\n\r\n    switch (type) {\r\n      case enums.Algorithm.Dijkstra:\r\n        name = \"Dijkstra's\";\r\n        break;\r\n      case enums.Algorithm.AStar:\r\n        name = \"A* (A Star)\";\r\n        break;\r\n      case enums.Algorithm.Bfs:\r\n        name = \"Breadth first search\";\r\n        break;\r\n      case enums.Algorithm.Dfs:\r\n        name = \"Depth first search\";\r\n        break;\r\n    }\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * return nodes in path order\r\n   * @param destination destination node\r\n   */\r\n  public static getNodesAsPath(destination: Node) {\r\n    const nodesInShortestPath: Node[] = [];\r\n    let currentNode = destination;\r\n    while (currentNode) {\r\n      nodesInShortestPath.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return nodesInShortestPath;\r\n  }\r\n\r\n  /**\r\n   * return unvisited neighbors of the given node\r\n   * @param node node\r\n   * @param grid grid\r\n   */\r\n  public static getUnvisitedNeighbors(node: Node, grid: Node[][]) {\r\n    const neighbors: Node[] = [];\r\n    const { row, column } = node;\r\n\r\n    if (row > 0) {\r\n      neighbors.push(grid[row - 1][column]);\r\n    }\r\n    if (row < grid.length - 1) {\r\n      neighbors.push(grid[row + 1][column]);\r\n    }\r\n    if (column > 0) {\r\n      neighbors.push(grid[row][column - 1]);\r\n    }\r\n    if (column < grid[0].length - 1) {\r\n      neighbors.push(grid[row][column + 1]);\r\n    }\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n  }\r\n}\r\n\r\nexport default NodeHelper;\r\n","import React from \"react\";\r\nimport * as enums from \"../../enums\";\r\nimport Dropdown from \"../common/dropdown\";\r\nimport DropdownOption from \"../common/typings/dropdownoption\";\r\nimport TerrainHelper from \"../../helper/terrainhelper\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\n\r\ninterface Props {\r\n  onVisualizeClick: (\r\n    e: React.MouseEvent<HTMLButtonElement, MouseEvent>\r\n  ) => void;\r\n  onResetStage: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\r\n  onSpeedChange: (e: React.ChangeEvent<HTMLElement>) => void;\r\n  onAlgorithmSelected: (option: DropdownOption) => void;\r\n  onTerrainOptionSelected: (option: DropdownOption) => void;\r\n  selectedTerrain: enums.TerrainType;\r\n  selectedAlgorithm: enums.Algorithm;\r\n  isPathFindingInProgress: boolean;\r\n}\r\n\r\nconst StageControls: React.FunctionComponent<Props> = (props) => {\r\n  const speedRangeOptions = {\r\n    min: 1,\r\n    max: 10,\r\n    default: 5,\r\n  };\r\n\r\n  return (\r\n    <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark\">\r\n      <span className=\"navbar-brand title\">Path finding algorithm</span>\r\n      <button\r\n        className=\"navbar-toggler\"\r\n        type=\"button\"\r\n        data-toggle=\"collapse\"\r\n        data-target=\"#navbarSupportedContent\"\r\n        aria-controls=\"navbarSupportedContent\"\r\n        aria-expanded=\"false\"\r\n        aria-label=\"Toggle navigation\"\r\n      >\r\n        <span className=\"navbar-toggler-icon\"></span>\r\n      </button>\r\n\r\n      <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n        <ul className=\"navbar-nav mr-auto\">\r\n          <Dropdown\r\n            id=\"algorithm-dropdown\"\r\n            classname=\"algorithm-selected-item\"\r\n            disabled={props.isPathFindingInProgress}\r\n            onOptionSelected={props.onAlgorithmSelected}\r\n            options={NodeHelper.getAlgorithmOptions(props.selectedAlgorithm)}\r\n          />\r\n          <Dropdown\r\n            id=\"terrain-dropdown\"\r\n            classname=\"terrain-selected-item\"\r\n            disabled={props.isPathFindingInProgress}\r\n            onOptionSelected={props.onTerrainOptionSelected}\r\n            options={TerrainHelper.getTerrainOption(props.selectedTerrain)}\r\n          />\r\n          <li className=\"nav-item\">\r\n            &nbsp;&nbsp;&nbsp;&nbsp;\r\n            <button\r\n              className=\"btn btn-success\"\r\n              onClick={props.onVisualizeClick}\r\n              disabled={props.isPathFindingInProgress}\r\n            >\r\n              Visualize\r\n            </button>\r\n          </li>\r\n          <li className=\"nav-item dropdown\">\r\n            &nbsp;&nbsp;&nbsp;&nbsp;\r\n            <button\r\n              className=\"btn btn-warning\"\r\n              onClick={props.onResetStage}\r\n              disabled={props.isPathFindingInProgress}\r\n            >\r\n              Reset\r\n            </button>\r\n          </li>\r\n          <li className=\"range\">\r\n            <p>Visualizing speed</p>\r\n            <input\r\n              type=\"range\"\r\n              min={speedRangeOptions.min}\r\n              max={speedRangeOptions.max}\r\n              defaultValue={speedRangeOptions.default}\r\n              onChange={props.onSpeedChange}\r\n            />\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </nav>\r\n  );\r\n};\r\n\r\nexport default StageControls;\r\n","import React from \"react\";\r\nimport classNames from \"classnames\";\r\nimport * as constants from \"../../constants\";\r\n\r\nconst NodeDescriptor: React.FunctionComponent = () => {\r\n  /**\r\n   * get node descriptor\r\n   * @param id id of descriptor\r\n   * @param text text to display\r\n   * @param classNames classnames to add\r\n   */\r\n  const getDescripor = (id: string, text: string, classNames: string) => {\r\n    return (\r\n      <div id={id} className=\"descriptor\">\r\n        <div className={classNames} />\r\n        &nbsp;\r\n        <span>{text}</span>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  const cssClass = constants.NodeClass;\r\n\r\n  return (\r\n    <div className=\"grid-descriptor\">\r\n      {getDescripor(\r\n        \"startNode\",\r\n        \"Start Node\",\r\n        classNames(cssClass.node, cssClass.start)\r\n      )}\r\n      {getDescripor(\r\n        \"destinationNode\",\r\n        \"Destination Node\",\r\n        classNames(cssClass.node, cssClass.destination)\r\n      )}\r\n      {getDescripor(\r\n        \"pathNode\",\r\n        \"Path Node\",\r\n        classNames(cssClass.node, cssClass.path)\r\n      )}\r\n      {getDescripor(\r\n        \"unvisitedNode\",\r\n        \"Unvisited Node\",\r\n        classNames(cssClass.node)\r\n      )}\r\n      {getDescripor(\r\n        \"visitedNode\",\r\n        \"Visited Node\",\r\n        classNames(cssClass.node, cssClass.visited)\r\n      )}\r\n      {getDescripor(\r\n        \"brickNode\",\r\n        \"Brick Node\",\r\n        classNames(cssClass.node, cssClass.brick)\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NodeDescriptor;\r\n","import ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport UtilityHelper from \"../../helper/utilityhelper\";\r\n\r\nclass RandomTerrain implements ITerrainGenerator {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * get terrain\r\n   */\r\n  public getTerrain(): number[][] {\r\n    let terrain: number[][] = [];\r\n\r\n    for (let row of this.nodes) {\r\n      terrain.push(UtilityHelper.generateRandomArray(10, 0, row.length - 1));\r\n    }\r\n\r\n    return terrain;\r\n  }\r\n}\r\n\r\nexport default RandomTerrain;\r\n","import ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport UtilityHelper from \"../../helper/utilityhelper\";\r\n\r\nclass RecursiveDivision implements ITerrainGenerator {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * Divide grid\r\n   * @param terrain terrain\r\n   * @param rowStart row start\r\n   * @param rowEnd row end\r\n   * @param colStart column start\r\n   * @param colEnd column end\r\n   */\r\n  private divide(\r\n    terrain: number[][],\r\n    rowStart: number,\r\n    rowEnd: number,\r\n    colStart: number,\r\n    colEnd: number\r\n  ) {\r\n    if (colEnd - colStart <= 0 || rowEnd - rowStart <= 0) {\r\n      return;\r\n    }\r\n\r\n    let width = colEnd - colStart + 1;\r\n    let height = rowEnd - rowStart + 1;\r\n\r\n    if (width <= height) {\r\n      // horizontal cut\r\n      let row = UtilityHelper.getRamdonNumber(rowStart, rowEnd);\r\n\r\n      for (let i = colStart; i <= colEnd; i++) {\r\n        // make a opening at column start\r\n        if (i === colStart) {\r\n          continue;\r\n        }\r\n\r\n        terrain[row].push(i);\r\n      }\r\n\r\n      this.divide(terrain, rowStart, row - 2, colStart, colEnd);\r\n      this.divide(terrain, row + 2, rowEnd, colStart, colEnd);\r\n    } else {\r\n      // vertical cut\r\n      let col = UtilityHelper.getRamdonNumber(colStart, colEnd);\r\n      let row = UtilityHelper.getRamdonNumber(rowStart, rowEnd);\r\n\r\n      for (let i = rowStart; i <= rowEnd; i++) {\r\n        // make a opening at row start\r\n        if (i === row) {\r\n          continue;\r\n        }\r\n\r\n        terrain[i].push(col);\r\n      }\r\n\r\n      this.divide(terrain, rowStart, rowEnd, colStart, col - 2);\r\n      this.divide(terrain, rowStart, rowEnd, col + 2, colEnd);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * get terrain\r\n   */\r\n  public getTerrain(): number[][] {\r\n    let terrain: number[][] = [];\r\n    let rowStart = 0;\r\n    let rowEnd = this.nodes.length - 1;\r\n    let colStart = 0;\r\n    let colEnd = this.nodes[0].length - 1;\r\n\r\n    this.nodes.forEach(() => {\r\n      terrain.push([]);\r\n    });\r\n\r\n    this.divide(terrain, rowStart, rowEnd, colStart, colEnd);\r\n\r\n    return terrain;\r\n  }\r\n}\r\n\r\nexport default RecursiveDivision;\r\n","import ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\nclass DiagonalLineTerrain implements ITerrainGenerator {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * get terrain\r\n   */\r\n  public getTerrain(): number[][] {\r\n    let terrain: number[][] = [];\r\n    let row = 1;\r\n    let column = 1;\r\n\r\n    for (let i = 0; i < 18; i++) {\r\n      if (i > row) {\r\n        terrain.push([\r\n          row + i,\r\n          column + i,\r\n          row + i + 10,\r\n          column + i + 10,\r\n          row + i + 20,\r\n          column + i + 20,\r\n          row + i + 30,\r\n          column + i + 30,\r\n        ]);\r\n      } else {\r\n        terrain.push([]);\r\n      }\r\n    }\r\n\r\n    return terrain;\r\n  }\r\n}\r\n\r\nexport default DiagonalLineTerrain;\r\n","import * as enums from \"../../enums\";\r\nimport RandomTerrain from \"./randomterrain\";\r\nimport RecursiveDivision from \"./recursivedivision\";\r\nimport ITerrainGenerator from \"./iterraingenerator\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport DiagonalLineTerrain from \"./diagonallineterrain\";\r\n\r\nclass TerrainEngine {\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * set terrain i grid\r\n   * @param terrainType terrain type\r\n   */\r\n  public setTerrain(terrainType: enums.TerrainType) {\r\n    let terrainGenerator: ITerrainGenerator;\r\n\r\n    try {\r\n      switch (terrainType) {\r\n        case enums.TerrainType.RandomBricks:\r\n          terrainGenerator = new RandomTerrain(this.nodes);\r\n          break;\r\n        case enums.TerrainType.DiagonalLines:\r\n          terrainGenerator = new DiagonalLineTerrain(this.nodes);\r\n          break;\r\n        case enums.TerrainType.RecursiveDivision:\r\n          terrainGenerator = new RecursiveDivision(this.nodes);\r\n          break;\r\n        default:\r\n          throw new Error(\"Terrain not found :|\");\r\n      }\r\n\r\n      let terrain = terrainGenerator.getTerrain();\r\n      this.mapTerrainToNodes(this.nodes, terrain);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * map terrain to nodes\r\n   * @param nodes nodes\r\n   * @param terrain terrain\r\n   */\r\n  private mapTerrainToNodes(nodes: Node[][], terrain: number[][]) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      let row = nodes[i];\r\n      let terrainRow = terrain[i];\r\n      for (let j = 0; j < terrainRow.length; j++) {\r\n        let node = row[terrainRow[j]];\r\n        if (!node.isStart && !node.isDestination) {\r\n          row[terrainRow[j]].isBrick = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default TerrainEngine;\r\n","/**\r\n * Algorithm ref - https://en.wikipedia.org/wiki/Breadth-first_search\r\n *\r\n * 1  procedure BFS(G, root) is\r\n * 2      let Q be a queue\r\n * 3      label root as discovered\r\n * 4      Q.enqueue(root)\r\n * 5      while Q is not empty do\r\n * 6          v := Q.dequeue()\r\n * 7          if v is the goal then\r\n * 8              return v\r\n * 9          for all edges from v to w in G.adjacentEdges(v) do\r\n * 10             if w is not labeled as discovered then\r\n * 11                 label w as discovered\r\n * 12                 w.parent := v\r\n * 13                 Q.enqueue(w)\r\n */\r\n\r\nimport IPathFinder from \"./ipathfinder\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\nclass Bfs implements IPathFinder {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * find path to destination\r\n   * @param startNode start node\r\n   * @param destinationNode destination node\r\n   */\r\n  find(startNode: Node, destinationNode: Node): Node[][] {\r\n    let queue = [];\r\n    let visitedNodes = [];\r\n\r\n    startNode.isVisited = true;\r\n    queue.push(startNode);\r\n\r\n    while (queue.length > 0) {\r\n      let current = queue.shift();\r\n\r\n      if (current) {\r\n        if (current.isBrick) {\r\n          continue;\r\n        }\r\n\r\n        if (current === destinationNode) {\r\n          break;\r\n        }\r\n\r\n        let unvisitedNodes = NodeHelper.getUnvisitedNeighbors(\r\n          current,\r\n          this.nodes\r\n        );\r\n        for (let nieghbour of unvisitedNodes) {\r\n          nieghbour.isVisited = true;\r\n          nieghbour.previousNode = current;\r\n          queue.push(nieghbour);\r\n          visitedNodes.push(nieghbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    const path: Node[] = NodeHelper.getNodesAsPath(destinationNode);\r\n\r\n    return [visitedNodes, path];\r\n  }\r\n}\r\n\r\nexport default Bfs;\r\n","/**\r\n * Algorithm ref : https://en.wikipedia.org/wiki/Depth-first_search\r\n *\r\n * procedure DFS_iterative(G, v) is\r\n *  let S be a stack\r\n *   S.push(v)\r\n *   while S is not empty do\r\n *       v = S.pop()\r\n *       if v is not labeled as discovered then\r\n *           label v as discovered\r\n *           for all edges from v to w in G.adjacentEdges(v) do\r\n *               S.push(w)\r\n */\r\n\r\nimport IPathFinder from \"./ipathfinder\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\nclass Dfs implements IPathFinder {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * find path\r\n   * @param startNode start node\r\n   * @param destinationNode destination node\r\n   */\r\n  public find(startNode: Node, destinationNode: Node): Node[][] {\r\n    let stack = [];\r\n    let visitedNodes = [];\r\n\r\n    stack.push(startNode);\r\n\r\n    while (stack.length > 0) {\r\n      let current = stack.pop();\r\n\r\n      if (current) {\r\n        if (current.isBrick) {\r\n          continue;\r\n        }\r\n\r\n        if (!current.isVisited) {\r\n          visitedNodes.push(current);\r\n          current.isVisited = true;\r\n\r\n          let neighbours = NodeHelper.getUnvisitedNeighbors(\r\n            current,\r\n            this.nodes\r\n          );\r\n          for (const neighbour of neighbours) {\r\n            neighbour.previousNode = current;\r\n            stack.push(neighbour);\r\n          }\r\n        }\r\n\r\n        if (current === destinationNode) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    const path: Node[] = NodeHelper.getNodesAsPath(destinationNode);\r\n\r\n    return [visitedNodes, path];\r\n  }\r\n}\r\n\r\nexport default Dfs;\r\n","/**\r\n * Algorithm ref - https://en.wikipedia.org/wiki/A*_search_algorithm\r\n */\r\n\r\nimport IPathFinder from \"./ipathfinder\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\ninterface AStarNode {\r\n  row: number;\r\n  column: number;\r\n  isVisited: boolean;\r\n  isBrick: boolean;\r\n  previousNode: any;\r\n  gScore: number;\r\n  fScore: number;\r\n  isStart: boolean;\r\n  isDestination: boolean;\r\n}\r\n\r\nclass AStar implements IPathFinder {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * find path\r\n   * @param startNode start node\r\n   * @param destinationNode destination node\r\n   */\r\n  public find(startNode: Node, destinationNode: Node): Node[][] {\r\n    let visitedAStarNodes: AStarNode[] = [];\r\n    let openSet: AStarNode[] = [];\r\n\r\n    let grid = this.mapNodeToAStarNode(this.nodes);\r\n    const [start, goal] = this.getStartAndDestination(grid);\r\n\r\n    // set g and f values of start node\r\n    start.gScore = 0;\r\n    start.fScore = this.getHeuristicValue(start, goal);\r\n\r\n    // initially push start node which is the know node\r\n    openSet.push(start);\r\n\r\n    while (openSet.length > 0) {\r\n      // sort openset based on fScore and\r\n      // set current element as node having lowest fScore\r\n      this.sortNodeByFScore(openSet);\r\n      let current = openSet.shift();\r\n\r\n      if (current) {\r\n        current.isVisited = true;\r\n        // if current and goal nodes are same, we reached destination\r\n        if (current === goal) {\r\n          break;\r\n        }\r\n\r\n        if (current.isBrick) {\r\n          continue;\r\n        }\r\n\r\n        let neighbors = this.getNeighbors(current, grid);\r\n\r\n        for (const neighbor of neighbors) {\r\n          // find tentative gScore. node distance is taken as 1\r\n          let tentative_gScore = current.gScore + 1;\r\n          if (tentative_gScore < neighbor.gScore) {\r\n            // find heuristic distance between neighbour and destination node\r\n            let heuristicValue = this.getHeuristicValue(neighbor, goal);\r\n            neighbor.previousNode = current;\r\n            neighbor.gScore = tentative_gScore;\r\n            neighbor.fScore = neighbor.gScore + heuristicValue;\r\n\r\n            // check if neighbour is already added to open set collection\r\n            let index = openSet.indexOf(neighbor);\r\n            if (index === -1) {\r\n              openSet.push(neighbor);\r\n              visitedAStarNodes.push(neighbor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // arrange nodes in path order\r\n    let aStarPath = this.getNodesAsPath(goal);\r\n    // get visited nodes\r\n    let visitedNodes = this.mapAstarNodeToNode(\r\n      visitedAStarNodes.filter((i) => i.isVisited)\r\n    );\r\n    let path = this.mapAstarNodeToNode(aStarPath);\r\n\r\n    return [visitedNodes, path];\r\n  }\r\n\r\n  /**\r\n   * return nodes in path order\r\n   * @param destination destination node\r\n   */\r\n  private getNodesAsPath(destination: AStarNode) {\r\n    const nodesInShortestPath: AStarNode[] = [];\r\n    let currentNode = destination;\r\n    while (currentNode) {\r\n      nodesInShortestPath.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n\r\n    return nodesInShortestPath;\r\n  }\r\n\r\n  /**\r\n   * map AStarNode to Node\r\n   * @param visitedNodes visited nodes\r\n   */\r\n  private mapAstarNodeToNode = (visitedNodes: AStarNode[]) => {\r\n    let nodes: Node[] = [];\r\n    for (let astarNode of visitedNodes) {\r\n      let node: Node = {\r\n        row: astarNode.row,\r\n        column: astarNode.column,\r\n        distance: Infinity,\r\n        isBrick: false,\r\n        isDestination: astarNode.isDestination,\r\n        isStart: astarNode.isStart,\r\n        isVisited: true,\r\n        previousNode: astarNode.previousNode,\r\n      };\r\n\r\n      nodes.push(node);\r\n    }\r\n\r\n    return nodes;\r\n  };\r\n\r\n  /**\r\n   * return neighbors of the given node\r\n   * @param node node\r\n   * @param grid grid\r\n   */\r\n  private getNeighbors(node: AStarNode, grid: AStarNode[][]) {\r\n    const neighbors: AStarNode[] = [];\r\n    const { row, column } = node;\r\n\r\n    if (row > 0) {\r\n      neighbors.push(grid[row - 1][column]);\r\n    }\r\n    if (row < grid.length - 1) {\r\n      neighbors.push(grid[row + 1][column]);\r\n    }\r\n    if (column > 0) {\r\n      neighbors.push(grid[row][column - 1]);\r\n    }\r\n    if (column < grid[0].length - 1) {\r\n      neighbors.push(grid[row][column + 1]);\r\n    }\r\n    return neighbors;\r\n  }\r\n\r\n  /**\r\n   * return nodes in sorted order based on fScore\r\n   * @param nodes nodes\r\n   */\r\n  private sortNodeByFScore(nodes: AStarNode[]) {\r\n    nodes.sort((a: AStarNode, b: AStarNode) => a.fScore - b.fScore);\r\n  }\r\n\r\n  /**\r\n   * return heuristic distance\r\n   * @param node1 node1\r\n   * @param node2 node2\r\n   */\r\n  private getHeuristicValue(node1: AStarNode, node2: AStarNode) {\r\n    let heuristicValue = 0;\r\n    let rowDiff = Math.abs(node1.row - node2.row);\r\n    let colDiff = Math.abs(node1.column - node2.column);\r\n    heuristicValue = rowDiff + colDiff;\r\n\r\n    return heuristicValue;\r\n  }\r\n\r\n  /**\r\n   * find start and destination node from grid\r\n   * @param grid grid\r\n   */\r\n  private getStartAndDestination(grid: AStarNode[][]) {\r\n    let start = this.getEmptyAStartNode();\r\n    let goal = this.getEmptyAStartNode();\r\n\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        if (node.isStart) {\r\n          start = node;\r\n        }\r\n        if (node.isDestination) {\r\n          goal = node;\r\n        }\r\n      }\r\n    }\r\n\r\n    return [start, goal];\r\n  }\r\n\r\n  /**\r\n   * init empty node\r\n   */\r\n  private getEmptyAStartNode() {\r\n    let node: AStarNode = {\r\n      row: 0,\r\n      column: 0,\r\n      isBrick: false,\r\n      isStart: false,\r\n      isDestination: false,\r\n      fScore: Infinity,\r\n      gScore: Infinity,\r\n      isVisited: false,\r\n      previousNode: undefined,\r\n    };\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * flatten node to Astar node\r\n   * @param grid grid\r\n   */\r\n  private mapNodeToAStarNode(grid: Node[][]) {\r\n    let nodes: AStarNode[][] = [];\r\n\r\n    for (const row of grid) {\r\n      let rowItems: AStarNode[] = [];\r\n\r\n      for (const node of row) {\r\n        let aStarNode: AStarNode = {\r\n          row: node.row,\r\n          column: node.column,\r\n          isBrick: node.isBrick,\r\n          isStart: node.isStart,\r\n          isDestination: node.isDestination,\r\n          fScore: Infinity,\r\n          gScore: Infinity,\r\n          isVisited: false,\r\n          previousNode: undefined,\r\n        };\r\n\r\n        rowItems.push(aStarNode);\r\n      }\r\n\r\n      nodes.push(rowItems);\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n}\r\n\r\nexport default AStar;\r\n","/**\r\n * Algorithm ref - https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\n */\r\n\r\nimport IPathFinder from \"./ipathfinder\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport Node from \"../../components/grid/typings/node\";\r\n\r\nclass Dijkstra implements IPathFinder {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  /**\r\n   * constructor\r\n   */\r\n  constructor(nodes: Node[][]) {\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  /**\r\n   * find shortest path\r\n   */\r\n  public find = (startNode: Node, destinationNode: Node) => {\r\n    let visitedNodes: Node[] = [];\r\n    let unvisitedNodes: Node[] = [];\r\n\r\n    // distance to start node is 0\r\n    startNode.distance = 0;\r\n    // get all nodes\r\n    unvisitedNodes = this.flatten2DNodeArray(this.nodes);\r\n\r\n    while (!!unvisitedNodes.length) {\r\n      // sort the nodes by distance\r\n      this.sortNodeByDistance(unvisitedNodes);\r\n\r\n      // get node with shortest distance\r\n      let adjacentNode = unvisitedNodes.shift();\r\n\r\n      if (adjacentNode) {\r\n        // if node is a brick then no need to do check\r\n        if (adjacentNode.isBrick) {\r\n          continue;\r\n        }\r\n\r\n        // if distance is inifinity, then it means path finding is blocked\r\n        if (adjacentNode.distance === Infinity) {\r\n          break;\r\n        }\r\n\r\n        // set node as visited adn push to visited node array\r\n        adjacentNode.isVisited = true;\r\n        visitedNodes.push(adjacentNode);\r\n\r\n        // we had reached the destination, stop searching\r\n        if (adjacentNode === destinationNode) {\r\n          break;\r\n        }\r\n\r\n        this.updateDistanceOfUnvisitedNeighbors(adjacentNode, this.nodes);\r\n      }\r\n    }\r\n\r\n    const path: Node[] = NodeHelper.getNodesAsPath(destinationNode);\r\n\r\n    return [visitedNodes, path];\r\n  };\r\n\r\n  private updateDistanceOfUnvisitedNeighbors(node: Node, grid: Node[][]) {\r\n    const unvisitedNeighbours = NodeHelper.getUnvisitedNeighbors(node, grid);\r\n\r\n    for (const neighbor of unvisitedNeighbours) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * return nodes in sorted order based on distance\r\n   * @param nodes nodes\r\n   */\r\n  private sortNodeByDistance(nodes: Node[]) {\r\n    nodes.sort((a: Node, b: Node) => a.distance - b.distance);\r\n  }\r\n\r\n  /**\r\n   * flatten 2D grid to array of nodes\r\n   * @param grid grid\r\n   */\r\n  private flatten2DNodeArray(grid: Node[][]) {\r\n    let nodes: Node[] = [];\r\n\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n}\r\n\r\nexport default Dijkstra;\r\n","import Bfs from \"./bfs\";\r\nimport Dfs from \"./dfs\";\r\nimport AStar from \"./astar\";\r\nimport Dijkstra from \"./dijkstra\";\r\nimport * as enums from \"../../enums\";\r\nimport IPathFinder from \"./ipathfinder\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport PathFindingOptions from \"./pathfindingoptions\";\r\nimport Node from \"../../components/grid/typings/node\";\r\nimport UtilityHelper from \"../../helper/utilityhelper\";\r\n\r\nclass PathFindingEngine {\r\n  // holds nodes\r\n  private nodes: Node[][];\r\n\r\n  // path finding options\r\n  private options: PathFindingOptions;\r\n\r\n  constructor(nodes: Node[][], options: PathFindingOptions) {\r\n    this.nodes = nodes;\r\n    this.options = options;\r\n  }\r\n\r\n  /**\r\n   * find shortest path\r\n   * @param startNode start node\r\n   * @param destinationNode destination node1\r\n   * @param algorithm selected algorithm\r\n   */\r\n  public find = async (\r\n    startNode: Node,\r\n    destinationNode: Node,\r\n    algorithm: enums.Algorithm\r\n  ) => {\r\n    try {\r\n      let pathFinder: IPathFinder;\r\n\r\n      switch (algorithm) {\r\n        case enums.Algorithm.Dijkstra:\r\n          pathFinder = new Dijkstra(this.nodes);\r\n          break;\r\n        case enums.Algorithm.Bfs:\r\n          pathFinder = new Bfs(this.nodes);\r\n          break;\r\n        case enums.Algorithm.Dfs:\r\n          pathFinder = new Dfs(this.nodes);\r\n          break;\r\n        case enums.Algorithm.AStar:\r\n          pathFinder = new AStar(this.nodes);\r\n          break;\r\n        default:\r\n          throw new Error(\"Algorithm implementation not found !!\");\r\n      }\r\n\r\n      const [visitedNodes, nodesInShortestPath] = pathFinder.find(\r\n        startNode,\r\n        destinationNode\r\n      );\r\n\r\n      await this.animate(visitedNodes, nodesInShortestPath);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  };\r\n\r\n  private animate = async (\r\n    visitedNodes: Node[],\r\n    nodesInShortestPath: Node[]\r\n  ) => {\r\n    for (let i = 0; i < visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length - 1) {\r\n        for (let j = 0; j < nodesInShortestPath.length; j++) {\r\n          const node = nodesInShortestPath[j];\r\n          if (!this.isStartOrDestination(node)) {\r\n            let nodeElement = NodeHelper.getNodeFromDOM(node.row, node.column);\r\n            nodeElement?.classList.remove(\"visited\");\r\n            nodeElement?.classList.add(\"path\");\r\n\r\n            await UtilityHelper.sleep(this.options.getAnimationSpeed());\r\n          }\r\n        }\r\n      }\r\n\r\n      const node = visitedNodes[i];\r\n      if (!this.isStartOrDestination(node)) {\r\n        let nodeElement = NodeHelper.getNodeFromDOM(node.row, node.column);\r\n        nodeElement?.classList.add(\"visited\");\r\n      }\r\n\r\n      await UtilityHelper.sleep(this.options.getAnimationSpeed());\r\n    }\r\n  };\r\n\r\n  /**\r\n   * return true if node is start or destination\r\n   * @param node node\r\n   */\r\n  private isStartOrDestination(node: Node) {\r\n    return node.isStart || node.isDestination;\r\n  }\r\n}\r\n\r\nexport default PathFindingEngine;\r\n","import React from \"react\";\r\nimport Grid from \"../grid/grid\";\r\nimport * as enums from \"../../enums\";\r\nimport StageFooter from \"./stagefooter\";\r\nimport Node from \"../grid/typings/node\";\r\nimport settings from \"../../appsettings\";\r\nimport StageControls from \"./stagecontrols\";\r\nimport NodeHelper from \"../../helper/nodehelper\";\r\nimport NodeDescriptor from \"../grid/nodedescriptor\";\r\nimport DropdownOption from \"../common/typings/dropdownoption\";\r\nimport TerrainEngine from \"../../algorithms/terrain/terrainengine\";\r\nimport PathFindingEngine from \"../../algorithms/pathfinding/pathfindingengine\";\r\nimport PathFindingOptions from \"../../algorithms/pathfinding/pathfindingoptions\";\r\n\r\ninterface State {\r\n  renderedOn: number;\r\n  renderNodes: boolean;\r\n}\r\n\r\ninterface Props {}\r\n\r\nclass Stage extends React.Component<Props, State> {\r\n  // number of rows in grid\r\n  private numberOfRows = 20;\r\n\r\n  // number of columns in a row\r\n  private numberOfColumns = 50;\r\n\r\n  // holds currently dragged node type\r\n  private draggedNodeType = enums.NodeType.None;\r\n\r\n  // holds nodes\r\n  private nodes: Node[][] = [];\r\n\r\n  // selected path finding algorithm\r\n  private selectedAlgorithm = enums.Algorithm.Dijkstra;\r\n\r\n  // holds node position.\r\n  private nodePositions: number[][] = [];\r\n\r\n  // selected terrain\r\n  private selectedTerrain = enums.TerrainType.None;\r\n\r\n  // holds boolean flag for pan started or not\r\n  private isPanStarted = false;\r\n\r\n  // holds flag if path fining is in progress or not\r\n  private isPathFindingInProgress = false;\r\n\r\n  // hold defult animation speed\r\n  private animationSpeed: number = settings.animationSpeed.default;\r\n\r\n  /**\r\n   * constructor for stage component\r\n   */\r\n  constructor(props: Props, state: State) {\r\n    super(props, state);\r\n    this.state = {\r\n      renderedOn: 0,\r\n      renderNodes: true,\r\n    };\r\n    this.resetStage(enums.TerrainType.None, false);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"stage\">\r\n        <StageControls\r\n          onSpeedChange={this.onSpeedChange}\r\n          onResetStage={this.onResetStage}\r\n          onVisualizeClick={this.onVisualizeClick}\r\n          onTerrainOptionSelected={this.onTerrainOptionSelected}\r\n          selectedTerrain={this.selectedTerrain}\r\n          onAlgorithmSelected={this.onAlgorithmOptionSelected}\r\n          selectedAlgorithm={this.selectedAlgorithm}\r\n          isPathFindingInProgress={this.isPathFindingInProgress}\r\n        />\r\n        <NodeDescriptor />\r\n        {this.state.renderNodes ? (\r\n          <Grid\r\n            id=\"grid\"\r\n            nodes={this.nodes}\r\n            onNodeDropEnd={this.onNodeDropEnd}\r\n            onNodeDragStart={this.onNodeDragStart}\r\n            onNodeMouseEnter={this.onNodeMouseEnter}\r\n            onGridContainerMouseUp={this.onGridContainerMouseUp}\r\n            onGridContainerMouseDown={this.onGridContainerMouseDown}\r\n            isPathFindingInProgress={this.isPathFindingInProgress}\r\n          />\r\n        ) : null}\r\n        <StageFooter selectedAlgorithm={this.selectedAlgorithm} />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * set animation speed\r\n   * @param index index of speed\r\n   */\r\n  private setAnimationSpeed = (index = 0) => {\r\n    this.animationSpeed = NodeHelper.getAnimationSpeed(\r\n      index === 0 ? settings.animationSpeed.default : index\r\n    );\r\n  };\r\n\r\n  /**\r\n   * get animation speed\r\n   */\r\n  private getAnimationSpeed = () => {\r\n    return this.animationSpeed;\r\n  };\r\n\r\n  /**\r\n   * on animation speed change\r\n   * @param event event\r\n   */\r\n  private onSpeedChange = (event: React.ChangeEvent<HTMLElement>) => {\r\n    let target: any = event.target;\r\n    let weight = parseInt(target.value);\r\n    this.setAnimationSpeed(weight);\r\n  };\r\n\r\n  /**\r\n   * mouse up event for grid container\r\n   */\r\n  private onGridContainerMouseUp = (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => {\r\n    this.isPanStarted = false;\r\n  };\r\n\r\n  /**\r\n   * mouse down event for grid container\r\n   */\r\n  private onGridContainerMouseDown = (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => {\r\n    let target: any = e.target;\r\n    this.isPanStarted = true;\r\n    NodeHelper.toggleBrick(target, this.nodes);\r\n    this.setState({ renderedOn: Date.now() });\r\n  };\r\n\r\n  /**\r\n   * on mouse enter of node\r\n   */\r\n  private onNodeMouseEnter = (\r\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => {\r\n    if (this.isPanStarted) {\r\n      let target: any = e.target;\r\n      NodeHelper.toggleBrick(target, this.nodes);\r\n      this.setState({ renderedOn: Date.now() });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when algorithm option is selected\r\n   */\r\n  private onAlgorithmOptionSelected = (option: DropdownOption) => {\r\n    if (this.selectedAlgorithm !== option.id) {\r\n      this.selectedAlgorithm = option.id;\r\n      this.setState({ renderedOn: Date.now() });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when terrain option is selected\r\n   */\r\n  private onTerrainOptionSelected = (option: DropdownOption) => {\r\n    if (this.selectedTerrain !== option.id) {\r\n      // reset stage on terrain change\r\n      this.resetStage(option.id, false);\r\n\r\n      this.setState({ renderNodes: false }, () => {\r\n        if (this.selectedTerrain !== enums.TerrainType.None) {\r\n          const terrainEngine = new TerrainEngine(this.nodes);\r\n          terrainEngine.setTerrain(this.selectedTerrain);\r\n        }\r\n\r\n        this.setState({ renderNodes: true });\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when visualize button is clicked\r\n   */\r\n  private onResetStage = async (\r\n    e: React.MouseEvent<HTMLButtonElement, MouseEvent>\r\n  ) => {\r\n    this.resetStage(enums.TerrainType.None);\r\n  };\r\n\r\n  /**\r\n   * triggered when visualize button is clicked\r\n   */\r\n  private onVisualizeClick = async (\r\n    e: React.MouseEvent<HTMLButtonElement, MouseEvent>\r\n  ) => {\r\n    this.isPathFindingInProgress = true;\r\n    this.setState({ renderedOn: Date.now() });\r\n\r\n    const startRow = this.nodePositions[0][0];\r\n    const startColumn = this.nodePositions[0][1];\r\n    const destinationRow = this.nodePositions[1][0];\r\n    const destinationColumn = this.nodePositions[1][1];\r\n\r\n    let startNode = this.nodes[startRow][startColumn];\r\n    startNode.isStart = true;\r\n\r\n    let destinationNode = this.nodes[destinationRow][destinationColumn];\r\n    destinationNode.isDestination = true;\r\n\r\n    let options: PathFindingOptions = {\r\n      getAnimationSpeed: this.getAnimationSpeed,\r\n    };\r\n\r\n    let pathfindingEngine = new PathFindingEngine(this.nodes, options);\r\n    await pathfindingEngine.find(\r\n      startNode,\r\n      destinationNode,\r\n      this.selectedAlgorithm\r\n    );\r\n\r\n    this.isPathFindingInProgress = false;\r\n    this.setState({ renderedOn: Date.now() });\r\n  };\r\n\r\n  /**\r\n   * triggered when a node is dragged\r\n   */\r\n  private onNodeDragStart = (e: React.DragEvent<HTMLDivElement>) => {\r\n    let target: any = e.target;\r\n    if (\r\n      NodeHelper.isNode(target) &&\r\n      (NodeHelper.isStartNode(target) || NodeHelper.isDestinationNode(target))\r\n    ) {\r\n      let nodeType = NodeHelper.getNodeType(target);\r\n      this.draggedNodeType = nodeType;\r\n\r\n      let cssClass = NodeHelper.getNodeClass(nodeType);\r\n      target.classList.remove(cssClass);\r\n      target.setAttribute(\"draggable\", \"false\");\r\n    }\r\n  };\r\n\r\n  /**\r\n   * triggered when node drop\r\n   */\r\n  private onNodeDropEnd = (e: React.DragEvent<HTMLDivElement>) => {\r\n    let element: any = e.target;\r\n    let x = e.clientX;\r\n    let y = e.clientY;\r\n    let currentElement = document.elementFromPoint(x, y);\r\n    let cssClass = NodeHelper.getNodeClass(this.draggedNodeType);\r\n    if (cssClass !== \"\") {\r\n      if (\r\n        currentElement &&\r\n        NodeHelper.isNode(currentElement) &&\r\n        !NodeHelper.isStartNode(currentElement) &&\r\n        !NodeHelper.isDestinationNode(currentElement)\r\n      ) {\r\n        element = currentElement;\r\n      }\r\n      element.classList.add(cssClass);\r\n      element.setAttribute(\"draggable\", \"true\");\r\n\r\n      let newPosition = NodeHelper.getNodePositionFromElemet(element);\r\n      if (newPosition) {\r\n        // nodePositions 0th index holds start node position\r\n        // and index 1 holds destination node position\r\n        if (this.draggedNodeType === enums.NodeType.Start) {\r\n          this.updateStartOrDestinationNode(0, newPosition);\r\n        } else if (this.draggedNodeType === enums.NodeType.Destination) {\r\n          this.updateStartOrDestinationNode(1, newPosition);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.draggedNodeType = enums.NodeType.None;\r\n    this.isPanStarted = false;\r\n  };\r\n\r\n  /**\r\n   * update start of destination node based on index\r\n   * @param index index of nodePositions\r\n   * @param newPosition new node position\r\n   */\r\n  private updateStartOrDestinationNode(index: number, newPosition: number[]) {\r\n    let position = this.nodePositions[index];\r\n    let row = position[0];\r\n    let column = position[1];\r\n\r\n    this.nodes[row][column].isStart = false;\r\n    this.nodes[row][column].isDestination = false;\r\n    this.nodePositions[index] = newPosition;\r\n  }\r\n\r\n  /**\r\n   * reset stage\r\n   */\r\n  private resetStage = (\r\n    terrain: enums.TerrainType,\r\n    doRerenderNodes: boolean = true\r\n  ) => {\r\n    this.selectedTerrain = terrain;\r\n    this.nodePositions = NodeHelper.getDefaultNodePosition();\r\n    this.nodes = NodeHelper.initNodes(\r\n      this.numberOfRows,\r\n      this.numberOfColumns,\r\n      this.nodePositions\r\n    );\r\n\r\n    if (doRerenderNodes) {\r\n      this.setState({ renderNodes: false }, () => {\r\n        setTimeout(() => {\r\n          this.setState({ renderNodes: true });\r\n        }, 0);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\nexport default Stage;\r\n","import React from \"react\";\nimport Stage from \"./components/stage/stage\";\n\nfunction App() {\n  return <Stage />;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}